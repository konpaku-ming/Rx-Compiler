/*
Test Package: Semantic-2
Test Target: comprehensive
Author: Wenxin Zheng
Time: 2025-08-17
Verdict: Success
Test Name: Advanced Control Flow and Logic Puzzle
Summary: This test comprehensively evaluates compiler optimizations for:
Details:
Deeply nested and complex control flow structures (if, while, for).
Intricate boolean logic and state transitions.
Optimization of loop invariants and branch prediction.
Correct handling of variable lifetimes across complex scopes.
Function calls within deeply nested loops.
*/

// Unified RNG: Parkâ€“Miller (a=16807, m=2147483647) using Schrage method to avoid overflow
fn pm_rand_update(x: i32) -> i32 {
    let a: i32 = 16807;
    let m: i32 = 2147483647;
    let q: i32 = 127773; // m / a
    let r: i32 = 2836; // m % a
    let k: i32 = x / q;
    let mut new_x: i32 = a * (x - k * q) - r * k;
    if (new_x <= 0) {
        new_x += m;
    }
    return new_x;
}

// comprehensive35.rx - Advanced Control Flow and Logic Puzzle
// This test comprehensively evaluates compiler optimizations for:
// - Deeply nested and complex control flow structures (if, while, for).
// - Intricate boolean logic and state transitions.
// - Optimization of loop invariants and branch prediction.
// - Correct handling of variable lifetimes across complex scopes.
// - Function calls within deeply nested loops.

const MAZE_SIZE: usize = 20;
const MAX_STEPS: i32 = 1000;

fn main() {
    let mut maze: [[i32; MAZE_SIZE]; MAZE_SIZE] = [[0; MAZE_SIZE]; MAZE_SIZE];
    generate_maze(&mut maze, 54321);

    let start_x: usize = 1;
    let start_y: usize = 1;
    maze[start_y][start_x] = 0;

    let end_x: usize = MAZE_SIZE - 2;
    let end_y: usize = MAZE_SIZE - 2;
    maze[end_y][end_x] = 0;

    let path_len: i32 = solve_maze(
        &mut maze,
        start_x as i32,
        start_y as i32,
        end_x as i32,
        end_y as i32,
    );
    printlnInt(path_len);

    let puzzle_result: i32 = solve_logic_puzzle();
    printlnInt(puzzle_result);

    let error_val: i32 = run_control_flow_puzzle();
    printlnInt(error_val);

    printlnInt(9999);
    exit(0);
}

fn generate_maze(maze: &mut [[i32; MAZE_SIZE]; MAZE_SIZE], seed: i32) {
    let mut current_seed: i32 = seed;
    let mut i: usize = 0;
    while (i < MAZE_SIZE) {
        let mut j: usize = 0;
        while (j < MAZE_SIZE) {
            if (i == 0 || j == 0 || i == MAZE_SIZE - 1 || j == MAZE_SIZE - 1) {
                maze[i][j] = 1;
            } else {
                current_seed = (pm_rand_update(current_seed) / 65536) % 32768;
                if (current_seed % 4 == 0) {
                    maze[i][j] = 1;
                } else {
                    maze[i][j] = 0;
                }
            }
            j = j + 1;
        }
        i = i + 1;
    }
}

fn solve_maze(
    maze: &mut [[i32; MAZE_SIZE]; MAZE_SIZE],
    start_x: i32,
    start_y: i32,
    end_x: i32,
    end_y: i32,
) -> i32 {
    let mut x: i32 = start_x;
    let mut y: i32 = start_y;
    let mut steps: i32 = 0;
    let mut dir: i32 = 0;

    while (steps < MAX_STEPS) {
        if (x == end_x && y == end_y) {
            return steps;
        }

        let mut turned: bool = false;
        let mut i: i32 = 0;
        while (i < 4) {
            let next_dir: i32 = (dir + 3 + i) % 4;
            let mut next_x: i32 = x;
            let mut next_y: i32 = y;

            if (next_dir == 0) {
                next_y = next_y - 1;
            } else if (next_dir == 1) {
                next_x = next_x + 1;
            } else if (next_dir == 2) {
                next_y = next_y + 1;
            } else {
                next_x = next_x - 1;
            }

            if (maze[next_y as usize][next_x as usize] == 0) {
                x = next_x;
                y = next_y;
                dir = next_dir;
                turned = true;
                break;
            }
            i = i + 1;
        }

        if (!turned) {
            return -1;
        }
        steps = steps + 1;
    }
    return -1;
}

fn solve_logic_puzzle() -> i32 {
    let mut a: i32 = 0;
    let mut b: i32 = 0;
    let mut c: i32 = 0;
    let mut d: i32 = 0;
    let mut e: i32 = 0;

    let mut i: i32 = 0;
    while (i < 10000) {
        a = (i % 5) + 1;
        b = (i / 5 % 5) + 1;
        c = (i / 25 % 5) + 1;
        d = (i / 125 % 5) + 1;
        e = (i / 625 % 5) + 1;

        if (a == b
            || a == c
            || a == d
            || a == e
            || b == c
            || b == d
            || b == e
            || c == d
            || c == e
            || d == e)
        {
            i = i + 1;
            continue;
        }

        let mut cond1: bool = (c == 1);
        let mut cond2: bool = (b == 2);
        let mut cond3: bool = (a == 5);
        let mut cond4: bool = (d != 1);
        let mut cond5: bool = (e == 4);

        if ((a == 3) != (cond1)) {
            i = i + 1;
            continue;
        }
        if ((b == 2) != (cond2)) {
            i = i + 1;
            continue;
        }
        if ((c == 4) != (cond3)) {
            i = i + 1;
            continue;
        }
        if ((d == 1) != (cond4)) {
            i = i + 1;
            continue;
        }
        if ((e == 3) != (cond5)) {
            i = i + 1;
            continue;
        }

        return a * 10000 + b * 1000 + c * 100 + d * 10 + e;
        i = i + 1;
    }
    return -1;
}

fn run_control_flow_puzzle() -> i32 {
    let mut x: i32 = 1;
    let mut y: i32 = 1;
    let mut z: i32 = 1;
    let mut i: i32 = 0;

    while (i < 100) {
        let mut j: i32 = 0;
        while (j < 5) {
            if (i % 2 == 0) {
                x = x + (y % (j + 1));
                if (x > 100) {
                    let mut k: i32 = 0;
                    while (k < 3) {
                        y = y + z * k;
                        k = k + 1;
                    }
                } else {
                    y = y + 1;
                }
            } else {
                y = y + (x % (j + 1));
                if (y > 150) {
                    let mut k: i32 = 0;
                    while (k < 4) {
                        z = z + x * k;
                        if (z % 3 == 0) {
                            x = x - k;
                        }
                        k = k + 1;
                    }
                }
            }
            j = j + 1;
        }

        if (i % 10 == 0) {
            let temp_val: i32 = x + y + z;
            if (temp_val % 7 == 0) {
                let mut immutable_val: i32 = i;
                if (i > 50) {
                    immutable_val = i + 1;
                }
                z = z + immutable_val;
            }
        }
        i = i + 1;
    }
    return x + y + z;
}

fn another_puzzle() {
    let mut state: i32 = 0;
    let mut counter: i32 = 0;
    let mut i: i32 = 0;
    while (i < 500) {
        counter = counter + 1;
        state = (state + i * 3) % 17;
        if (state < 5) {
            let mut j: i32 = 0;
            while (j < state) {
                counter = counter + j;
                j = j + 1;
            }
        } else if (state < 12) {
            let mut j: i32 = 10;
            while (j > state) {
                counter = counter - j;
                j = j - 1;
            }
        } else {
            counter = counter * 2;
            if (counter > 10000) {
                counter = counter / 3;
            }
        }
        i = i + 1;
    }
    printlnInt(counter);
}

fn yet_another_control_flow() {
    let mut a: i32 = 1;
    let mut b: i32 = 1;
    let mut i: i32 = 0;
    while (i < 10) {
        let mut j: i32 = 0;
        while (j < 10) {
            let mut k: i32 = 0;
            while (k < 10) {
                if ((i + j * 2 + k * 3) % 5 == 0) {
                    a = a + 1;
                } else {
                    b = b + 1;
                }
                if (a > b) {
                    let temp: i32 = a;
                    a = b;
                    b = temp;
                }
                k = k + 1;
            }
            j = j + 1;
        }
        i = i + 1;
    }
    printlnInt(a * 1000 + b);
}
