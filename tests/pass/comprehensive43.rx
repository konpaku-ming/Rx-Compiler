/*
Test Package: Semantic-2
Test Target: comprehensive
Author: Wenxin Zheng
Time: 2025-08-17
Verdict: Success
Test Name: Simple Stack-Based Interpreter
Summary: This test comprehensively evaluates compiler optimizations for:
Details:
Large switch-like dispatch loops for instruction processing.
Array manipulation for stack and program memory.
Deeply nested function calls and recursion simulation.
Complex conditional logic for jumps and control flow.
Performance of integer arithmetic and comparisons.
Mutability analysis in functions modifying shared state.
*/

// comprehensive43.rx - Simple Stack-Based Interpreter
// This test comprehensively evaluates compiler optimizations for:
// - Large switch-like dispatch loops for instruction processing.
// - Array manipulation for stack and program memory.
// - Deeply nested function calls and recursion simulation.
// - Complex conditional logic for jumps and control flow.
// - Performance of integer arithmetic and comparisons.
// - Mutability analysis in functions modifying shared state.

fn main() {
    let mut program: [i32; 256] = [0; 256];
    let mut stack: [i32; 256] = [0; 256];
    let mut sp: i32 = -1;
    let mut pc: i32 = 0;
    let mut halt: bool = false;

    // Opcodes: 1:PUSH, 2:POP, 3:ADD, 4:SUB, 5:MUL, 6:DIV, 7:JMP, 8:JZ, 9:JNZ, 10:EQ, 11:LT, 12:GT, 13:PRINT, 14:HALT, 15:DUP

    fn load_program(prog: &mut [i32; 256]) {
        // Calculate factorial of 8
        prog[0] = 1; prog[1] = 8;       // PUSH 8 (n)
        prog[2] = 1; prog[3] = 1;       // PUSH 1 (result)
        // Loop start (pc=4)
        prog[4] = 15;                   // DUP (duplicate n)
        prog[5] = 1; prog[6] = 1;       // PUSH 1
        prog[7] = 11;                   // LT (n < 1?)
        prog[8] = 9; prog[9] = 14;      // JNZ to loop_end (pc=18)
        // if n < 1, jump to print
        prog[10] = 7; prog[11] = 20;     // JMP to print_result (pc=30)
        // loop_body (pc=12)
        prog[12] = 5;                   // MUL (result = result * n)
        prog[13] = 1; prog[14] = -1;    // PUSH -1
        prog[15] = 3;                   // ADD (n = n - 1)
        prog[16] = 7; prog[17] = 4;      // JMP to loop_start (pc=4)
        // loop_end (pc=18)
        prog[18] = 2;                   // POP (n)
        prog[19] = 7; prog[20] = 12;     // JMP to loop_body (pc=12)
        // print_result (pc=21)
        prog[21] = 13;                  // PRINT result
        prog[22] = 14;                  // HALT

        // Some dead code to increase complexity
        let mut i: i32 = 30;
        while (i < 250) {
            prog[i as usize] = 1;
            prog[i as usize+1] = i;
            prog[i as usize+2] = 15;
            prog[i as usize+3] = 2;
            i = i + 4;
        }
    }

    // Hidden Error: This function is declared to take an immutable program array,
    // but it tries to modify it. This should cause a mutability conflict error.
    fn self_modify_code(prog: &mut [i32; 256], pc: i32) {
        if (pc > 10 && prog[pc as usize-1] == 15) { // If previous instruction was DUP
            prog[pc as usize] = 2; // Change next instruction to POP
        }
    }

    load_program(&mut program);

    while (!halt) {
        let instruction: i32 = program[pc as usize];
        pc = pc + 1;

        // This call introduces the hidden error.
        self_modify_code(&mut program, pc);

        if (instruction == 1) { // PUSH
            let value: i32 = program[pc as usize];
            pc = pc + 1;
            sp = sp + 1;
            stack[sp as usize] = value;
        } else if (instruction == 2) { // POP
            sp = sp - 1;
        } else if (instruction == 3) { // ADD
            let b: i32 = stack[sp as usize];
            sp = sp - 1;
            let a: i32 = stack[sp as usize];
            stack[sp as usize] = a + b;
        } else if (instruction == 4) { // SUB
            let b: i32 = stack[sp as usize];
            sp = sp - 1;
            let a: i32 = stack[sp as usize];
            stack[sp as usize] = a - b;
        } else if (instruction == 5) { // MUL
            let b: i32 = stack[sp as usize];
            sp = sp - 1;
            let a: i32 = stack[sp as usize];
            stack[sp as usize] = a * b;
        } else if (instruction == 6) { // DIV
            let b: i32 = stack[sp as usize];
            sp = sp - 1;
            let a: i32 = stack[sp as usize];
            stack[sp as usize] = a / b;
        } else if (instruction == 7) { // JMP
            pc = program[pc as usize];
        } else if (instruction == 8) { // JZ
            let val: i32 = stack[sp as usize];
            sp = sp - 1;
            if (val == 0) {
                pc = program[pc as usize];
            } else {
                pc = pc + 1;
            }
        } else if (instruction == 9) { // JNZ
            let val: i32 = stack[sp as usize];
            sp = sp - 1;
            if (val != 0) {
                pc = program[pc as usize];
            } else {
                pc = pc + 1;
            }
        } else if (instruction == 10) { // EQ
            let b: i32 = stack[sp as usize];
            sp = sp - 1;
            let a: i32 = stack[sp as usize];
            if (a == b) { stack[sp as usize] = 1; } else { stack[sp as usize] = 0; }
        } else if (instruction == 11) { // LT
            let b: i32 = stack[sp as usize];
            sp = sp - 1;
            let a: i32 = stack[sp as usize];
            if (a < b) { stack[sp as usize] = 1; } else { stack[sp as usize] = 0; }
        } else if (instruction == 12) { // GT
            let b: i32 = stack[sp as usize];
            sp = sp - 1;
            let a: i32 = stack[sp as usize];
            if (a > b) { stack[sp as usize] = 1; } else { stack[sp as usize] = 0; }
        } else if (instruction == 13) { // PRINT
            printlnInt(stack[sp as usize]);
        } else if (instruction == 14) { // HALT
            halt = true;
        } else if (instruction == 15) { // DUP
            let val: i32 = stack[sp as usize];
            sp = sp + 1;
            stack[sp as usize] = val;
        }

        if (pc < 0 || pc >= 256) {
            halt = true;
        }
    }
    exit(0);
}
