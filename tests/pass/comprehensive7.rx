/*
Test Package: Semantic-2
Test Target: comprehensive
Author: Wenxin Zheng
Time: 2025-08-17
Verdict: Success
Test Name: Comprehensive Test 7: Graph Algorithms and Network Analysis
Summary: This test focuses on compiler optimization of:
Details:
Graph traversal algorithm optimizations
Dynamic programming on graphs
Complex nested loop structures in graph algorithms
Path finding algorithm optimizations
Network flow algorithm optimizations
Graph data structure access pattern optimizations
*/

// comprehensive7.rx - Comprehensive Test 7: Graph Algorithms and Network Analysis
// This test focuses on compiler optimization of:
// - Graph traversal algorithm optimizations
// - Dynamic programming on graphs
// - Complex nested loop structures in graph algorithms
// - Path finding algorithm optimizations
// - Network flow algorithm optimizations
// - Graph data structure access pattern optimizations

fn main() {
    // Performance test marker - start
    printlnInt(1700);
    
    // Test 1: Graph traversal algorithms (DFS, BFS)
    // Tests optimization of recursive and iterative graph traversal
    testGraphTraversalAlgorithms();
    
    // Test 2: Shortest path algorithms
    // Tests optimization of dynamic programming and relaxation operations
    testShortestPathAlgorithms();
    
    // Test 3: Minimum spanning tree algorithms
    // Tests optimization of greedy algorithms and union-find operations
    testMinimumSpanningTreeAlgorithms();
    
    // Test 4: Network flow algorithms
    // Tests optimization of augmenting path algorithms
    testNetworkFlowAlgorithms();
    
    // Test 5: Graph connectivity and components
    // Tests optimization of component detection algorithms
    testGraphConnectivityAlgorithms();
    
    // Performance test marker - end
    printlnInt(1799);
    exit(0);
}

// Test 1: Graph Traversal Algorithms
fn testGraphTraversalAlgorithms() {
    printlnInt(1701); // Start graph traversal test
    
    // Create adjacency matrix for graph (50x50 nodes)
    let mut graph: [i32; 2500] = [0; 2500];
    initializeGraph(&mut graph, 50);
    
    // Test Depth-First Search
    let dfs_result: i32 = depthFirstSearch(&graph, 50, 0);
    printlnInt(dfs_result);
    
    // Test Breadth-First Search  
    let bfs_result: i32 = breadthFirstSearch(&graph, 50, 0);
    printlnInt(bfs_result);
    
    // Test iterative DFS
    let iterative_dfs_result: i32 = iterativeDepthFirstSearch(&graph, 50, 0);
    printlnInt(iterative_dfs_result);
    
    // Test cycle detection
    let cycle_result: i32 = detectCycles(&graph, 50);
    printlnInt(cycle_result);
    
    printlnInt(1702); // End graph traversal test
}

// Initialize graph with edges
fn initializeGraph(graph: &mut [i32; 2500], size: i32) {
    let mut i: i32 = 0;
    
    // Initialize adjacency matrix to 0
    while (i < size * size) {
        graph[i as usize] = 0;
        i = i + 1;
    }
    
    // Add edges based on pattern
    i = 0;
    while (i < size) {
        let mut j: i32 = 0;
        while (j < size) {
            if ((i != j) && (((i + j) % 7 == 0) || ((i * j) % 11 == 0))) {
                graph[(i * size + j) as usize] = 1 + (i + j) % 10; // Edge weight
                graph[(j * size + i) as usize] = 1 + (i + j) % 10; // Make undirected
            }
            j = j + 1;
        }
        i = i + 1;
    }
}

// Depth-First Search (recursive)
fn depthFirstSearch(graph: &[i32; 2500], size: i32, start: i32) -> i32 {
    let mut visited: [bool; 50] = [false; 50];
    return dfsRecursive(graph, size, start, &mut visited);
}

fn dfsRecursive(graph: &[i32; 2500], size: i32, node: i32, visited: &mut [bool; 50]) -> i32 {
    visited[node as usize] = true;
    let mut nodes_visited: i32 = 1;
    
    let mut neighbor: i32 = 0;
    while (neighbor < size) {
        if ((graph[(node * size + neighbor) as usize] > 0) && (!visited[neighbor as usize])) {
            nodes_visited = nodes_visited + dfsRecursive(graph, size, neighbor, visited);
        }
        neighbor = neighbor + 1;
    }
    
    return nodes_visited;
}

// Breadth-First Search (iterative with queue simulation)
fn breadthFirstSearch(graph: &[i32; 2500], size: i32, start: i32) -> i32 {
    let mut visited: [bool; 50] = [false; 50];
    let mut queue: [i32; 50] = [-1; 50];
    let mut queue_front: i32 = 0;
    let mut queue_rear: i32 = 0;
    let mut nodes_visited: i32 = 0;
    
    // Enqueue start node
    queue[queue_rear as usize] = start;
    queue_rear = queue_rear + 1;
    visited[start as usize] = true;
    
    while (queue_front < queue_rear) {
        let current_node: i32 = queue[queue_front as usize];
        queue_front = queue_front + 1;
        nodes_visited = nodes_visited + 1;
        
        // Visit all unvisited neighbors
        let mut neighbor: i32 = 0;
        while (neighbor < size) {
            if ((graph[(current_node * size + neighbor) as usize] > 0) && (!visited[neighbor as usize])) {
                visited[neighbor as usize] = true;
                queue[queue_rear as usize] = neighbor;
                queue_rear = queue_rear + 1;
            }
            neighbor = neighbor + 1;
        }
    }
    
    return nodes_visited;
}

// Iterative Depth-First Search using stack
fn iterativeDepthFirstSearch(graph: &[i32; 2500], size: i32, start: i32) -> i32 {
    let mut visited: [bool; 50] = [false; 50];
    let mut stack: [i32; 1250] = [-1; 1250]; // |G| ^ 2 / 2 theoretically
    let mut stack_top: i32 = 0;
    let mut nodes_visited: i32 = 0;
    
    // Push start node onto stack
    stack[stack_top as usize] = start;
    stack_top = stack_top + 1;
    
    while (stack_top > 0) {
        // Pop node from stack
        stack_top = stack_top - 1;
        let current_node: i32 = stack[stack_top as usize];
        
        if ((!visited[current_node as usize])) {
            visited[current_node as usize] = true;
            nodes_visited = nodes_visited + 1;
            
            // Push all unvisited neighbors onto stack
            let mut neighbor: i32 = 0;
            while (neighbor < size) {
                if ((graph[(current_node * size + neighbor) as usize] > 0) && (!visited[neighbor as usize])) {
                    stack[stack_top as usize] = neighbor;
                    stack_top = stack_top + 1;
                }
                neighbor = neighbor + 1;
            }
        }
    }
    
    return nodes_visited;
}

// Detect cycles in graph using DFS
fn detectCycles(graph: &[i32; 2500], size: i32) -> i32 {
    let mut visited: [bool; 50] = [false; 50];
    let mut in_recursion_stack: [bool; 50] = [false; 50];
    let mut cycles_found: i32 = 0;
    
    let mut i: i32 = 0;
    while (i < size) {
        if (!visited[i as usize]) {
            if (dfsCycleDetection(graph, size, i, &mut visited, &mut in_recursion_stack)) {
                cycles_found = cycles_found + 1;
            }
        }
        i = i + 1;
    }
    
    return cycles_found;
}

fn dfsCycleDetection(graph: &[i32; 2500], size: i32, node: i32, 
                    visited: &mut [bool; 50], in_recursion_stack: &mut [bool; 50]) -> bool {
    visited[node as usize] = true;
    in_recursion_stack[node as usize] = true;
    
    let mut neighbor: i32 = 0;
    while (neighbor < size) {
        if (graph[(node * size + neighbor) as usize] > 0) {
            if (!visited[neighbor as usize]) {
                if (dfsCycleDetection(graph, size, neighbor, visited, in_recursion_stack)) {
                    return true;
                }
            } else if (in_recursion_stack[neighbor as usize]) {
                return true;
            }
        }
        neighbor = neighbor + 1;
    }
    
    in_recursion_stack[node as usize] = false;
    return false;
}

// Test 2: Shortest Path Algorithms
fn testShortestPathAlgorithms() {
    printlnInt(1703); // Start shortest path test
    
    let mut graph: [i32; 2500] = [0; 2500];
    initializeWeightedGraph(&mut graph, 50);
    
    // Test Dijkstra's algorithm
    let dijkstra_result: i32 = dijkstraShortestPath(&graph, 50, 0);
    printlnInt(dijkstra_result);
    
    // Test Floyd-Warshall algorithm (limited size)
    let floyd_result: i32 = floydWarshallAllPairs(&graph, 20);
    printlnInt(floyd_result);
    
    // Test Bellman-Ford algorithm
    let bellman_result: i32 = bellmanFordShortestPath(&graph, 50, 0);
    printlnInt(bellman_result);
    
    printlnInt(1704); // End shortest path test
}

// Initialize weighted graph
fn initializeWeightedGraph(graph: &mut [i32; 2500], size: i32) {
    let mut i: i32 = 0;
    
    // Initialize with infinity (represented by 9999)
    while (i < size * size) {
        graph[i as usize] = 9999;
        i = i + 1;
    }
    
    // Set diagonal to 0 (distance from node to itself)
    i = 0;
    while (i < size) {
        graph[(i * size + i) as usize] = 0;
        i = i + 1;
    }
    
    // Add weighted edges
    i = 0;
    while (i < size) {
        let mut j: i32 = 0;
        while (j < size) {
            if ((i != j) && (((i + j) % 5 == 0) || ((i * 2 + j) % 7 == 0))) {
                let weight: i32 = 1 + ((i + j) % 15);
                graph[(i * size + j) as usize] = weight;
            }
            j = j + 1;
        }
        i = i + 1;
    }
}

// Dijkstra's shortest path algorithm
fn dijkstraShortestPath(graph: &[i32; 2500], size: i32, start: i32) -> i32 {
    let mut distances: [i32; 50] = [9999; 50];
    let mut visited: [bool; 50] = [false; 50];
    let mut total_distance: i32 = 0;
    
    distances[start as usize] = 0;
    
    let mut count: i32 = 0;
    while (count < size) {
        // Find minimum distance unvisited node
        let mut min_distance: i32 = 9999;
        let mut min_node: i32 = -1;
        let mut i: i32 = 0;
        
        while (i < size) {
            if ((!visited[i as usize]) && (distances[i as usize] < min_distance)) {
                min_distance = distances[i as usize];
                min_node = i;
            }
            i = i + 1;
        }
        
        if (min_node == -1) {
            break;
        }
        
        visited[min_node as usize] = true;
        total_distance = total_distance + distances[min_node as usize];
        
        // Update distances to neighbors
        i = 0;
        while (i < size) {
            if ((!visited[i as usize]) && (graph[(min_node * size + i) as usize] != 9999)) {
                let new_distance: i32 = distances[min_node as usize] + graph[(min_node * size + i) as usize];
                if (new_distance < distances[i as usize]) {
                    distances[i as usize] = new_distance;
                }
            }
            i = i + 1;
        }
        
        count = count + 1;
    }
    
    return total_distance;
}

// Floyd-Warshall all-pairs shortest path
fn floydWarshallAllPairs(graph: &[i32; 2500], size: i32) -> i32 {
    // Create distance matrix (limited to 20x20 for performance)
    let actual_size: i32 = if (size > 20) { 20 } else { size };
    
    let mut distances: [i32; 400] = [9999; 400];
    
    // Initialize distances
    let mut i: i32 = 0;
    while (i < actual_size) {
        let mut j: i32 = 0;
        while (j < actual_size) {
            distances[(i * actual_size + j) as usize] = graph[(i * size + j) as usize];
            j = j + 1;
        }
        i = i + 1;
    }
    
    // Floyd-Warshall main loop
    let mut k: i32 = 0;
    while (k < actual_size) {
        i = 0;
        while (i < actual_size) {
            let mut j: i32 = 0;
            while (j < actual_size) {
                if ((distances[(i * actual_size + k) as usize] != 9999) && 
                   (distances[(k * actual_size + j) as usize] != 9999)) {
                    let new_distance: i32 = distances[(i * actual_size + k) as usize] + distances[(k * actual_size + j) as usize];
                    if (new_distance < distances[(i * actual_size + j) as usize]) {
                        distances[(i * actual_size + j) as usize] = new_distance;
                    }
                }
                j = j + 1;
            }
            i = i + 1;
        }
        k = k + 1;
    }
    
    // Sum all shortest paths
    let mut total_distance: i32 = 0;
    i = 0;
    while (i < actual_size) {
        let mut j: i32 = 0;
        while (j < actual_size) {
            if ((i != j) && (distances[(i * actual_size + j) as usize] != 9999)) {
                total_distance = total_distance + distances[(i * actual_size + j) as usize];
            }
            j = j + 1;
        }
        i = i + 1;
    }
    
    return total_distance;
}

// Bellman-Ford shortest path algorithm
fn bellmanFordShortestPath(graph: &[i32; 2500], size: i32, start: i32) -> i32 {
    let mut distances: [i32; 50] = [9999; 50];
    distances[start as usize] = 0;
    
    let mut negative_cycles: i32 = 0;
    // Relax edges size-1 times
    let mut iteration: i32 = 0;
    while (iteration < size - 1) {
        let mut i: i32 = 0;
        while (i < size) {
            let mut j: i32 = 0;
            while (j < size) {
                if ((graph[(i * size + j) as usize] != 9999) && (distances[i as usize] != 9999)) {
                    let new_distance: i32 = distances[i as usize] + graph[(i * size + j) as usize];
                    if (new_distance < distances[j as usize]) {
                        negative_cycles = negative_cycles + 1;
                    }
                }
                j = j + 1;
            }
            i = i + 1;
        }
        iteration = iteration + 1;
    }
    
    // Check for negative cycles (one more iteration)
    let mut i: i32 = 0;
    while (i < size) {
        let mut j: i32 = 0;
        while (j < size) {
            if ((graph[(i * size + j) as usize] != 9999) && (distances[i as usize] != 9999)) {
                let new_distance: i32 = distances[i as usize] + graph[(i * size + j) as usize];
                if (new_distance < distances[j as usize]) {
                    negative_cycles = negative_cycles + 1;
                }
            }
            j = j + 1;
        }
        i = i + 1;
    }
    
    // Return sum of all distances
    let mut total_distance: i32 = 0;
    i = 0;
    while (i < size) {
        if (distances[i as usize] != 9999) {
            total_distance = total_distance + distances[i as usize];
        }
        i = i + 1;
    }
    
    return total_distance + negative_cycles;
}

// Test 3: Minimum Spanning Tree Algorithms
fn testMinimumSpanningTreeAlgorithms() {
    printlnInt(1705); // Start MST test
    
    let mut graph: [i32; 2500] = [0; 2500];
    initializeWeightedGraph(&mut graph, 50);
    
    // Test Kruskal's algorithm
    let kruskal_result: i32 = kruskalMST(&graph, 50);
    printlnInt(kruskal_result);
    
    // Test Prim's algorithm
    let prim_result: i32 = primMST(&graph, 50);
    printlnInt(prim_result);
    
    printlnInt(1706); // End MST test
}

// Kruskal's MST algorithm (simplified without Union-Find)
fn kruskalMST(graph: &[i32; 2500], size: i32) -> i32 {
    // Create edge list
    let mut edges: [i32; 1500] = [0; 1500]; // [weight, src, dest] triplets
    let mut edge_count: i32 = 0;
    
    // Extract edges from adjacency matrix
    let mut i: i32 = 0;
    while (i < size && edge_count < 500) {
        let mut j: i32 = i + 1;
        while (j < size && edge_count < 500) {
            if ((graph[(i * size + j) as usize] != 9999) && (graph[(i * size + j) as usize] != 0)) {
                edges[(edge_count as usize) * 3] = graph[(i * size + j) as usize]; // weight
                edges[(edge_count as usize) * 3 + 1] = i; // source
                edges[(edge_count as usize) * 3 + 2] = j; // destination
                edge_count = edge_count + 1;
            }
            j = j + 1;
        }
        i = i + 1;
    }
    
    // Sort edges by weight (simple bubble sort)
    sortEdgesByWeight(&mut edges, edge_count);
    
    // Build MST using simple cycle detection
    let mut mst_weight: i32 = 0;
    let mut mst_edges: i32 = 0;
    let mut edge_index: i32 = 0;
    
    while (edge_index < edge_count && mst_edges < size - 1) {
        let weight: i32 = edges[(edge_index as usize) * 3];
        let src: i32 = edges[(edge_index as usize) * 3 + 1];
        let dest: i32 = edges[(edge_index as usize) * 3 + 2];
        
        // Simple check: add edge if it doesn't create obvious cycles
        if (src != dest) {
            mst_weight = mst_weight + weight;
            mst_edges = mst_edges + 1;
        }
        
        edge_index = edge_index + 1;
    }
    
    return mst_weight;
}

// Sort edges by weight using bubble sort
fn sortEdgesByWeight(edges: &mut [i32; 1500], edge_count: i32) {
    let mut i: i32 = 0;
    while (i < edge_count - 1) {
        let mut j: i32 = 0;
        while (j < edge_count - i - 1) {
            if (edges[(j as usize) * 3] > edges[((j as usize) + 1) * 3]) {
                // Swap edges
                let temp_weight: i32 = edges[(j as usize) * 3];
                let temp_src: i32 = edges[(j as usize) * 3 + 1];
                let temp_dest: i32 = edges[(j as usize) * 3 + 2];
                
                edges[(j as usize) * 3] = edges[((j as usize) + 1) * 3];
                edges[(j as usize) * 3 + 1] = edges[((j as usize) + 1) * 3 + 1];
                edges[(j as usize) * 3 + 2] = edges[((j as usize) + 1) * 3 + 2];
                
                edges[((j as usize) + 1) * 3] = temp_weight;
                edges[((j as usize) + 1) * 3 + 1] = temp_src;
                edges[((j as usize) + 1) * 3 + 2] = temp_dest;
            }
            j = j + 1;
        }
        i = i + 1;
    }
}

// Prim's MST algorithm
fn primMST(graph: &[i32; 2500], size: i32) -> i32 {
    let mut key: [i32; 50] = [9999; 50];
    let mut mst_set: [bool; 50] = [false; 50];
    let mut mst_weight: i32 = 0;
    
    key[0] = 0; // Start from vertex 0
    
    let mut count: i32 = 0;
    while (count < size) {
        // Find minimum key vertex not in MST
        let mut min_key: i32 = 9999;
        let mut min_index: i32 = -1;
        let mut v: i32 = 0;
        
        while (v < size) {
            if ((!mst_set[v as usize]) && (key[v as usize] < min_key)) {
                min_key = key[v as usize];
                min_index = v;
            }
            v = v + 1;
        }
        
        if (min_index == -1) {
            break;
        }
        
        mst_set[min_index as usize] = true;
        mst_weight = mst_weight + key[min_index as usize];
        
        // Update key values of adjacent vertices
        v = 0;
        while (v < size) {
            if ((!mst_set[v as usize]) && (graph[(min_index * size + v) as usize] != 9999) &&
                (graph[(min_index * size + v) as usize] != 0) && (graph[(min_index * size + v) as usize] < key[v as usize])) {
                key[v as usize] = graph[(min_index * size + v) as usize];
            }
            v = v + 1;
        }
        
        count = count + 1;
    }
    
    return mst_weight;
}

// Test 4: Network Flow Algorithms
fn testNetworkFlowAlgorithms() {
    printlnInt(1707); // Start network flow test
    
    let mut capacity: [i32; 900] = [0; 900]; // 30x30 capacity matrix
    initializeFlowNetwork(&mut capacity, 30);
    
    // Test Ford-Fulkerson max flow
    let max_flow_result: i32 = fordFulkersonMaxFlow(&capacity, 30, 0, 29);
    printlnInt(max_flow_result);
    
    // Test min-cost max flow (simplified)
    let min_cost_result: i32 = minCostMaxFlow(&capacity, 30);
    printlnInt(min_cost_result);
    
    printlnInt(1708); // End network flow test
}

// Initialize flow network
fn initializeFlowNetwork(capacity: &mut [i32; 900], size: i32) {
    let mut i: i32 = 0;
    
    // Initialize all capacities to 0
    while (i < size * size) {
        capacity[i as usize] = 0;
        i = i + 1;
    }
    
    // Add capacity based on network topology
    i = 0;
    while (i < size - 1) {
        // Forward edges
        capacity[(i * size + (i + 1)) as usize] = 10 + (i % 20);
        
        // Some cross edges
        if (i + 5 < size) {
            capacity[(i * size + (i + 5)) as usize] = 5 + (i % 10);
        }
        
        // Some backward connections for complex flow
        if (i > 5) {
            capacity[(i * size + (i - 3)) as usize] = 3 + (i % 7);
        }
        
        i = i + 1;
    }
}

// Ford-Fulkerson max flow algorithm
fn fordFulkersonMaxFlow(capacity: &[i32; 900], size: i32, source: i32, sink: i32) -> i32 {
    let mut residual: [i32; 900] = [0; 900];
    let mut max_flow: i32 = 0;
    
    // Initialize residual graph
    let mut i: i32 = 0;
    while (i < size * size) {
        residual[i as usize] = capacity[i as usize];
        i = i + 1;
    }
    
    // Find augmenting paths
    let mut iteration: i32 = 0;
    while (iteration < 100) { // Limit iterations
        let mut parent: [i32; 30] = [-1; 30];
        let flow: i32 = bfsAugmentingPath(&residual, size, source, sink, &mut parent);
        
        if (flow == 0) {
            break; // No more augmenting paths
        }
        
        max_flow = max_flow + flow;
        
        // Update residual graph
        let mut v: i32 = sink;
        while (v != source) {
            let u: i32 = parent[v as usize];
            residual[(u * size + v) as usize] = residual[(u * size + v) as usize] - flow;
            residual[(v * size + u) as usize] = residual[(v * size + u) as usize] + flow;
            v = parent[v as usize];
        }
        
        iteration = iteration + 1;
    }
    
    return max_flow;
}

// BFS to find augmenting path
fn bfsAugmentingPath(residual: &[i32; 900], size: i32, source: i32, sink: i32, parent: &mut [i32; 30]) -> i32 {
    let mut visited: [bool; 30] = [false; 30];
    let mut queue: [i32; 30] = [-1; 30];
    let mut queue_front: i32 = 0;
    let mut queue_rear: i32 = 0;
    
    queue[queue_rear as usize] = source;
    queue_rear = queue_rear + 1;
    visited[source as usize] = true;
    parent[source as usize] = -1;
    
    while (queue_front < queue_rear) {
        let u: i32 = queue[queue_front as usize];
        queue_front = queue_front + 1;
        
        let mut v: i32 = 0;
        while (v < size) {
            if ((!visited[v as usize]) && (residual[(u * size + v) as usize] > 0)) {
                queue[queue_rear as usize] = v;
                queue_rear = queue_rear + 1;
                visited[v as usize] = true;
                parent[v as usize] = u;
                
                if (v == sink) {
                    // Found path to sink, calculate bottleneck capacity
                    let mut path_flow: i32 = 9999;
                    let mut current: i32 = sink;
                    
                    while (current != source) {
                        let prev: i32 = parent[current as usize];
                        if (residual[(prev * size + current) as usize] < path_flow) {
                            path_flow = residual[(prev * size + current) as usize];
                        }
                        current = prev;
                    }
                    
                    return path_flow;
                }
            }
            v = v + 1;
        }
    }
    
    return 0; // No augmenting path found
}

// Simplified min-cost max flow
fn minCostMaxFlow(capacity: &[i32; 900], size: i32) -> i32 {
    let mut total_cost: i32 = 0;
    let mut total_flow: i32 = 0;
    
    // Simple cost calculation based on distance
    let mut i: i32 = 0;
    while (i < size) {
        let mut j: i32 = 0;
        while (j < size) {
            if (capacity[(i * size + j) as usize] > 0) {
                let distance: i32 = if (i > j) { i - j } else { j - i };
                total_cost = total_cost + capacity[(i * size + j) as usize] * distance;
                total_flow = total_flow + capacity[(i * size + j) as usize];
            }
            j = j + 1;
        }
        i = i + 1;
    }
    
    return total_cost / (total_flow + 1); // Average cost per unit flow
}

// Test 5: Graph Connectivity Algorithms
fn testGraphConnectivityAlgorithms() {
    printlnInt(1709); // Start connectivity test
    
    let mut graph: [i32; 2500] = [0; 2500];
    initializeGraph(&mut graph, 50);
    
    // Test connected components
    let components_result: i32 = findConnectedComponents(&graph, 50);
    printlnInt(components_result);
    
    // Test strongly connected components (for directed graph)
    let scc_result: i32 = findStronglyConnectedComponents(&graph, 50);
    printlnInt(scc_result);
    
    // Test articulation points
    let articulation_result: i32 = findArticulationPoints(&mut graph, 50);
    printlnInt(articulation_result);
    
    // Test bridges
    let bridges_result: i32 = findBridges(&mut graph, 50);
    printlnInt(bridges_result);
    
    printlnInt(1710); // End connectivity test
}

// Find connected components using DFS
fn findConnectedComponents(graph: &[i32; 2500], size: i32) -> i32 {
    let mut visited: [bool; 50] = [false; 50];
    let mut components: i32 = 0;
    
    let mut i: i32 = 0;
    while (i < size) {
        if (!visited[i as usize]) {
            dfsComponentTraversal(graph, size, i, &mut visited);
            components = components + 1;
        }
        i = i + 1;
    }
    
    return components;
}

fn dfsComponentTraversal(graph: &[i32; 2500], size: i32, node: i32, visited: &mut [bool; 50]) {
    visited[node as usize] = true;
    
    let mut neighbor: i32 = 0;
    while (neighbor < size) {
        if ((graph[(node * size + neighbor) as usize] > 0) && (!visited[neighbor as usize])) {
            dfsComponentTraversal(graph, size, neighbor, visited);
        }
        neighbor = neighbor + 1;
    }
}

// Find strongly connected components using Kosaraju's algorithm
fn findStronglyConnectedComponents(graph: &[i32; 2500], size: i32) -> i32 {
    let mut visited: [bool; 50] = [false; 50];
    let mut finish_order: [i32; 50] = [0; 50];
    let mut finish_index: i32 = 0;
    
    // First DFS to get finish times
    let mut i: i32 = 0;
    while (i < size) {
        if (!visited[i as usize]) {
            dfsFinishTime(graph, size, i, &mut visited, &mut finish_order, &mut finish_index);
        }
        i = i + 1;
    }
    
    // Create transpose graph
    let mut transpose: [i32; 2500] = [0; 2500];
    i = 0;
    while (i < size) {
        let mut j: i32 = 0;
        while (j < size) {
            transpose[(j * size + i) as usize] = graph[(i * size + j) as usize];
            j = j + 1;
        }
        i = i + 1;
    }
    
    // Reset visited array
    i = 0;
    while (i < size) {
        visited[i as usize] = false;
        i = i + 1;
    }
    
    // Second DFS on transpose graph in reverse finish order
    let mut scc_count: i32 = 0;
    i = finish_index - 1;
    while (i >= 0) {
        let node: i32 = finish_order[i as usize];
        if (!visited[node as usize]) {
            dfsComponentTraversal(&transpose, size, node, &mut visited);
            scc_count = scc_count + 1;
        }
        i = i - 1;
    }
    
    return scc_count;
}

fn dfsFinishTime(graph: &[i32; 2500], size: i32, node: i32, visited: &mut [bool; 50], 
                finish_order: &mut [i32; 50], finish_index: &mut i32) {
    visited[node as usize] = true;
    
    let mut neighbor: i32 = 0;
    while (neighbor < size) {
        if ((graph[(node * size + neighbor) as usize] > 0) && (!visited[neighbor as usize])) {
            dfsFinishTime(graph, size, neighbor, visited, finish_order, finish_index);
        }
        neighbor = neighbor + 1;
    }
    
    finish_order[*finish_index as usize] = node;
    *finish_index = *finish_index + 1;
}

// Find articulation points (simplified)
fn findArticulationPoints(graph: &mut [i32; 2500], size: i32) -> i32 {
    let mut articulation_points: i32 = 0;
    
    // For each vertex, temporarily remove it and check connectivity
    let mut vertex: i32 = 0;
    while (vertex < size) {
        let original_components: i32 = findConnectedComponents(&*graph, size);
        
        // Temporarily remove vertex by setting its edges to 0
        let mut temp_edges: [i32; 50] = [0; 50];
        let mut i: i32 = 0;
        while (i < size) {
            temp_edges[i as usize] = graph[(vertex * size + i) as usize];
            graph[(vertex * size + i) as usize] = 0;
            graph[(i * size + vertex) as usize] = 0;
            i = i + 1;
        }
        
        let new_components: i32 = findConnectedComponents(&*graph, size);
        
        // Restore edges
        i = 0;
        while (i < size) {
            graph[(vertex * size + i) as usize] = temp_edges[i as usize];
            graph[(i * size + vertex) as usize] = temp_edges[i as usize];
            i = i + 1;
        }
        
        if (new_components > original_components) {
            articulation_points = articulation_points + 1;
        }
        
        vertex = vertex + 1;
    }
    
    return articulation_points;
}

// Find bridges (simplified)
fn findBridges(graph: &mut [i32; 2500], size: i32) -> i32 {
    let mut bridges: i32 = 0;
    
    // For each edge, temporarily remove it and check connectivity
    let mut i: i32 = 0;
    while (i < size) {
        let mut j: i32 = i + 1;
        while (j < size) {
            if (graph[(i * size + j) as usize] > 0) {
                let original_components: i32 = findConnectedComponents(&*graph, size);
                
                // Temporarily remove edge
                let temp_weight: i32 = graph[(i * size + j) as usize];
                graph[(i * size + j) as usize] = 0;
                graph[(j * size + i) as usize] = 0;
                
                let new_components: i32 = findConnectedComponents(&*graph, size);
                
                // Restore edge
                graph[(i * size + j) as usize] = temp_weight;
                graph[(j * size + i) as usize] = temp_weight;
                
                if (new_components > original_components) {
                    bridges = bridges + 1;
                }
            }
            j = j + 1;
        }
        i = i + 1;
    }
    
    return bridges;
}
