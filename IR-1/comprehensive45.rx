/*
Test Package: Semantic-2
Test Target: comprehensive
Author: Wenxin Zheng
Time: 2025-08-17
Verdict: Pass
Test Name: Advanced Data Compression (Lempel-Ziv-like)
Summary: This test comprehensively evaluates compiler optimizations for:
Details:
String-like operations on integer arrays.
Complex search algorithms within a sliding window.
Dynamic data structure behavior (dictionary) simulated with arrays.
High-demand loop optimizations for pattern matching.
Performance of array slicing and copying simulations.
Branching logic for handling matches vs. literals.
*/

// comprehensive45.rx - Advanced Data Compression (Lempel-Ziv-like)
// This test comprehensively evaluates compiler optimizations for:
// - String-like operations on integer arrays.
// - Complex search algorithms within a sliding window.
// - Dynamic data structure behavior (dictionary) simulated with arrays.
// - High-demand loop optimizations for pattern matching.
// - Performance of array slicing and copying simulations.
// - Branching logic for handling matches vs. literals.

fn main() {
    let mut input_data: [i32; 512] = [0; 512];
    let mut compressed_data: [i32; 512] = [0; 512];
    let mut compressed_len: i32 = 0;

    fn generate_input(data: &mut [i32; 512]) {
        let mut i: i32 = 0;
        while (i < 512) {
            if (i % 20 < 10) {
                data[i as usize] = (i % 10) + 65; // 'A' through 'J'
            } else {
                data[i as usize] = (i * 17 % 15) + 97; // 'a' through 'o'
            }
            i = i + 1;
        }
        // Create some long repeating patterns
        i = 100;
        while (i < 120) {
            data[i as usize] = data[i as usize - 20];
            i = i + 1;
        }
        i = 300;
        while (i < 330) {
            data[i as usize] = data[i as usize - 30];
            i = i + 1;
        }
    }

    fn find_longest_match(data: &[i32; 512], current_pos: i32, search_buffer_start: i32) -> i32 {
        let mut best_match_len: i32 = 0;
        let mut best_match_offset: i32 = 0;
        let max_lookahead: i32 = 18;

        let mut i: i32 = current_pos - 1;
        while (i >= search_buffer_start) {
            let mut current_match_len: i32 = 0;
            while (current_pos + current_match_len < 512 &&
                  current_match_len < max_lookahead &&
                  data[(i + current_match_len) as usize] == data[(current_pos + current_match_len) as usize]) {
                current_match_len = current_match_len + 1;
            }

            if (current_match_len > best_match_len) {
                best_match_len = current_match_len;
                best_match_offset = current_pos - i;
            }
            i = i - 1;
        }

        if (best_match_len >= 3) {
            return (best_match_offset * 1000) + best_match_len;
        }
        return 0;
    }

    generate_input(&mut input_data);

    let mut current_pos: i32 = 0;
    let window_size: i32 = 128;

    while (current_pos < 512) {
        let search_buffer_start: i32 = if (current_pos > window_size) {
            current_pos - window_size
        } else {
            0
        };

        let match_result: i32 = find_longest_match(&input_data, current_pos, search_buffer_start);

        if (match_result > 0) {
            let offset: i32 = match_result / 1000;
            let len: i32 = match_result % 1000;

            compressed_data[compressed_len as usize] = 1; // Type 1: match
            compressed_len = compressed_len + 1;
            compressed_data[compressed_len as usize] = offset;
            compressed_len = compressed_len + 1;
            compressed_data[compressed_len as usize] = len;
            compressed_len = compressed_len + 1;
            current_pos = current_pos + len;
        } else {
            // Fixed: declare and assign literal_value outside the inner if block
            // to ensure it is always in scope.
            let literal_value: i32 = input_data[current_pos as usize];
            if (compressed_len < 510) {
                compressed_data[compressed_len as usize] = 0; // Type 0: literal
                compressed_len = compressed_len + 1;
            }
            compressed_data[compressed_len as usize] = literal_value;
            compressed_len = compressed_len + 1;
            current_pos = current_pos + 1;
        }
    }

    let mut checksum: i32 = 0;
    let mut i: i32 = 0;
    while (i < compressed_len) {
        checksum = checksum + compressed_data[i as usize] * (i + 1);
        i = i + 1;
    }
    printlnInt(checksum);
    printlnInt(compressed_len);
    exit(0);
}
