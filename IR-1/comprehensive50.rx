/*
Test Package: Semantic-2
Test Target: comprehensive
Author: Wenxin Zheng
Time: 2025-08-17
Verdict: Pass
Test Name: Intricate State Machine and Protocol Simulation
Summary: This test comprehensively evaluates compiler optimizations for:
Details:
State transition logic in a complex, multi-state finite automaton
Optimization of array lookups for state transition tables
Branch prediction for handling various input events and state changes
Deeply nested function calls for processing protocol messages
Integer arithmetic for checksums and sequence number validation
Loop optimization for processing streams of input data
Handling of error states and recovery paths in the state machine.
*/

// comprehensive50.rx - Intricate State Machine and Protocol Simulation
// This test comprehensively evaluates compiler optimizations for:
// - State transition logic in a complex, multi-state finite automaton
// - Optimization of array lookups for state transition tables
// - Branch prediction for handling various input events and state changes
// - Deeply nested function calls for processing protocol messages
// - Integer arithmetic for checksums and sequence number validation
// - Loop optimization for processing streams of input data
// - Handling of error states and recovery paths in the state machine.

fn main() {
    let mut state: i32 = 0; // 0: IDLE, 1: CONNECTING, 2: CONNECTED, 3: DISCONNECTING, 4: ERROR
    let mut sequence_number: i32 = 0;
    let mut last_ack: i32 = -1;
    let mut retransmission_count: i32 = 0;

    let mut input_stream: [i32; 60] = [0; 60];
    let mut i: usize = 0;
    while (i < 60) {
        input_stream[i as usize] = i as i32 % 8;
        i = i + 1;
    }
    // Event types: 0: REQ_CONNECT, 1: ACK_CONNECT, 2: DATA, 3: ACK_DATA, 4: REQ_DISCONNECT, 5: ACK_DISCONNECT, 6: TIMEOUT, 7: CORRUPT_DATA

    i = 0;
    while (i < 60) {
        let event: i32 = input_stream[i as usize];
        let mut payload: i32 =  i as i32 * 10;

        state = process_event(state, event, payload, sequence_number, last_ack, retransmission_count);

        if (state == 1) { // CONNECTING
            sequence_number = 0;
            last_ack = -1;
        } else {
            if (state == 2) { // CONNECTED
                if (event == 2) { // DATA
                    sequence_number = sequence_number + 1;
                } else {
                    if (event == 3) { // ACK_DATA
                        last_ack = payload;
                    }
                }
            } else {
                if (state == 4) { // ERROR
                    // This is a compile error. The variable `new_state` is defined in a different scope.
                    // The intention might be to reset the state, but it's accessing an out-of-scope variable.
                    state = 0; // Compile Error: `new_state` is not defined in this scope
                    retransmission_count = 0;
                }
            }
        }

        if (last_ack < sequence_number - 5) {
            retransmission_count = retransmission_count + 1;
            if (retransmission_count > 3) {
                state = 4; // ERROR
            }
        }
        printInt(state);
        i = i + 1;
    }
    exit(0);
}

fn process_event(current_state: i32, event: i32, payload: i32, seq: i32, ack: i32, ret_count: i32) -> i32 {
    let mut new_state: i32 = current_state;

    if (current_state == 0) { // IDLE
        if (event == 0) { // REQ_CONNECT
            new_state = 1; // CONNECTING
        }
    } else {
        if (current_state == 1) { // CONNECTING
            if (event == 1) { // ACK_CONNECT
                new_state = 2; // CONNECTED
            } else {
                if (event == 6) { // TIMEOUT
                    new_state = 0; // IDLE
                }
            }
        } else {
            if (current_state == 2) { // CONNECTED
                if (event == 2) { // DATA
                    if (validate_checksum(payload)) {
                        // process data
                    } else {
                        new_state = 4; // ERROR
                    }
                } else {
                    if (event == 3) { // ACK_DATA
                        if (payload > ack) {
                            // update window
                        }
                    } else {
                        if (event == 4) { // REQ_DISCONNECT
                            new_state = 3; // DISCONNECTING
                        } else {
                            if (event == 7) { // CORRUPT_DATA
                                new_state = 4; // ERROR
                            }
                        }
                    }
                }
            } else {
                if (current_state == 3) { // DISCONNECTING
                    if (event == 5) { // ACK_DISCONNECT
                        new_state = 0; // IDLE
                    } else {
                        if (event == 6) { // TIMEOUT
                            new_state = 0; // IDLE
                        }
                    }
                } else {
                    if (current_state == 4) { // ERROR
                        // In a real scenario, this might trigger a reset.
                        // Here, we just stay in the error state.
                    }
                }
            }
        }
    }
    return complex_state_logic(new_state, event, payload);
}

fn validate_checksum(payload: i32) -> bool {
    // A simple, but potentially performance-intensive checksum logic
    let mut checksum: i32 = 0;
    let mut i: i32 = 1;
    while (i <= payload) {
        if (payload % i == 0) {
            checksum = checksum + i;
        }
        i = i + 1;
    }
    return checksum % 2 == 0;
}

fn complex_state_logic(state: i32, event: i32, payload: i32) -> i32 {
    let mut final_state: i32 = state;
    if (event == 6) { // TIMEOUT
        if (state == 2) { // CONNECTED
            final_state = perform_recovery(state, payload);
        }
    }

    let mut i: i32 = 0;
    let mut temp_val: i32 = payload;
    while (i < 5) {
        temp_val = temp_val / (i + 2) + i * i;
        i = i + 1;
    }

    if (temp_val % 10 == 0) {
        if (final_state != 4) {
            final_state = 4; // ERROR
        }
    }
    return final_state;
}

fn perform_recovery(state: i32, payload: i32) -> i32 {
    let mut recovery_score: i32 = 0;
    let mut i: i32 = 0;
    while (i < 10) {
        recovery_score = recovery_score + (payload % (i + 1));
        i = i + 1;
    }

    if (recovery_score > 20) {
        return state; // Recovery successful
    } else {
        return 4; // Recovery failed, go to ERROR state
    }
}

fn another_layer_of_protocol(event: i32, data: i32) -> i32 {
    let mut result: i32 = data;
    if (event == 2) { // DATA
        let mut i: i32 = 0;
        while (i < 5) {
            result = result + i;
            i = i + 1;
        }
    } else {
        if (event == 3) { // ACK_DATA
            result = result - 10;
        }
    }
    return result;
}

fn yet_another_protocol_function(val1: i32, val2: i32) -> i32 {
    let mut intermediate: i32 = val1 + val2;
    let mut k: i32 = 0;
    while (k < 3) {
        intermediate = another_layer_of_protocol(k, intermediate);
        k = k + 1;
    }
    return intermediate;
}

fn process_complex_packet(a: i32, b: i32, c: i32) -> i32 {
    let res1: i32 = yet_another_protocol_function(a, b);
    let res2: i32 = yet_another_protocol_function(b, c);
    let res3: i32 = yet_another_protocol_function(a, c);
    res1 - res2 + res3
}
