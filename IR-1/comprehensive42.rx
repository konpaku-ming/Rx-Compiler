/*
Test Package: Semantic-2
Test Target: comprehensive
Author: Wenxin Zheng
Time: 2025-08-17
Verdict: Pass
Test Name: Custom Memory Allocator Simulation
Summary: This test comprehensively evaluates compiler optimizations for:
Details:
Simulated pointer arithmetic and memory management through array manipulation.
Complex linked-list data structure updates within a large buffer.
Loop-intensive allocation and deallocation patterns to test performance.
Management of memory fragmentation and coalescing logic.
Optimization of deeply nested conditional statements for block management.
Scope resolution for variables across different allocation phases.
*/

// comprehensive42.rx - Custom Memory Allocator Simulation
// This test comprehensively evaluates compiler optimizations for:
// - Simulated pointer arithmetic and memory management through array manipulation.
// - Complex linked-list data structure updates within a large buffer.
// - Loop-intensive allocation and deallocation patterns to test performance.
// - Management of memory fragmentation and coalescing logic.
// - Optimization of deeply nested conditional statements for block management.
// - Scope resolution for variables across different allocation phases.

fn main() {
    let mut heap: [i32; 1024] = [0; 1024];
    let mut free_list_head: i32 = 0;
    // Total number of blocks in the heap (heap_size / block_size)
    let total_blocks: i32 = 64; // 1024 / 16

    fn init_heap(heap: &mut [i32; 1024], free_list_head: &mut i32) {
        let heap_size: i32 = 1024;
        let block_size: i32 = 16;
        let num_blocks: i32 = heap_size / block_size;
        let mut i: i32 = 0;
        while (i < num_blocks) {
            let current_addr: i32 = i * block_size;
            heap[current_addr as usize] = (i + 1) * block_size; // Next pointer
            i = i + 1;
        }
        heap[((num_blocks - 1) * block_size) as usize] = -1; // End of list
        *free_list_head = 0;
    }

    fn alloc(heap: &mut [i32; 1024], free_list_head: &mut i32) -> i32 {
        if (*free_list_head == -1) {
            return -1; // Out of memory
        }
        let block_addr: i32 = *free_list_head;
        *free_list_head = heap[block_addr as usize];
        heap[block_addr as usize] = -2; // Mark as allocated
        return block_addr;
    }

    fn free(heap: &mut [i32; 1024], free_list_head: &mut i32, addr: i32) {
        heap[addr as usize] = *free_list_head;
        *free_list_head = addr;
    }

    init_heap(&mut heap, &mut free_list_head);

    let mut allocations: [i32; 64] = [0; 64];
    let mut i: i32 = 0;
    let mut successful_allocs: i32 = 0;

    while (i < 64) {
        let addr: i32 = alloc(&mut heap, &mut free_list_head);
        if (addr != -1) {
            allocations[i as usize] = addr;
            successful_allocs = successful_allocs + 1;
        }
        i = i + 1;
    }

    i = 0;
    while (i < 32) {
        if (i % 2 == 0) {
            free(&mut heap, &mut free_list_head, allocations[i as usize]);
            allocations[i as usize] = -1;
        }
        i = i + 1;
    }

    i = 0;
    while (i < 16) {
        let addr: i32 = alloc(&mut heap, &mut free_list_head);
        if (addr != -1) {
            let mut j: i32 = 0;
            let mut placed: bool = false;
            while (j < 64) {
                if (allocations[j as usize] == -1 && !placed) {
                    allocations[j as usize] = addr;
                    placed = true;
                }
                j = j + 1;
            }
        }
        i = i + 1;
    }

    let mut active_blocks: i32 = 0;
    i = 0;
    while (i < 64) {
        if (allocations[i as usize] != -1) {
            active_blocks = active_blocks + 1;
        }
        i = i + 1;
    }

    // Compute fragmentation metric when enough blocks are active.
    // Hoisted variable to avoid scope error & guard against divide-by-zero.
    let mut fragmentation_metric: i32 = 0; // 0 means either fully used or not computed.
    if (active_blocks > 40) {
        let mut max_contiguous_free: i32 = 0;
        let mut current_contiguous: i32 = 0;
        let mut current_ptr: i32 = free_list_head;
        while (current_ptr != -1) {
            current_contiguous = current_contiguous + 1;
            let next_ptr: i32 = heap[current_ptr as usize];
            if (next_ptr != current_ptr + 16) {
                if (current_contiguous > max_contiguous_free) {
                    max_contiguous_free = current_contiguous;
                }
                current_contiguous = 0;
            }
            current_ptr = next_ptr;
        }
        // Safe denominator: remaining free blocks. If zero, fragmentation is defined as 0.
        let remaining_free: i32 = total_blocks - active_blocks; // could be 0
        if (remaining_free > 0) {
            fragmentation_metric = max_contiguous_free * 100 / remaining_free;
        } else {
            fragmentation_metric = 0; // No free space -> treat as no measurable fragmentation.
        }
    }

    if (active_blocks < 48) {
        let mut i: i32 = 32;
        while (i < 64) {
            if (i % 3 == 0) {
                if (allocations[i as usize] != -1) {
                    free(&mut heap, &mut free_list_head, allocations[i as usize]);
                    allocations[i as usize] = -1;
                }
            }
            i = i + 1;
        }
    }

    let mut final_check_sum: i32 = 0;
    i = 0;
    while (i < 1024) {
        if (heap[i as usize] == -2) {
            final_check_sum = final_check_sum + i;
        }
        i = i + 1;
    }

    printlnInt(fragmentation_metric); // 0 if (not computed or fully allocated)
    printlnInt(final_check_sum);
    exit(0);
}
