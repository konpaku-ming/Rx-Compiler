/*
Test Package: Semantic-2
Test Target: comprehensive
Author: Wenxin Zheng
Time: 2025-08-17
Verdict: Pass
Test Name: Multi-Agent Simulation on a 2D Grid
Summary: This test comprehensively evaluates compiler optimizations for:
Details:
Multi-dimensional array access and manipulation.
Complex object-oriented-style programming with structs.
Simulation loops with many state updates per tick.
Decision-making logic with deep conditional branches.
Interaction between multiple complex data structures.
*/

// Unified RNG: Parkâ€“Miller (a=16807, m=2147483647) using Schrage method to avoid overflow
fn pm_rand_update(x: i32) -> i32 {
    let a: i32 = 16807;
    let m: i32 = 2147483647;
    let q: i32 = 127773; // m / a
    let r: i32 = 2836; // m % a
    let mut k: i32 = x / q;
    let mut new_x: i32 = a * (x - k * q) - r * k;
    if (new_x <= 0) {
        new_x += m;
    }
    return new_x;
}

// comprehensive33.rx - Multi-Agent Simulation on a 2D Grid
// This test comprehensively evaluates compiler optimizations for:
// - Multi-dimensional array access and manipulation.
// - Complex object-oriented-style programming with structs.
// - Simulation loops with many state updates per tick.
// - Decision-making logic with deep conditional branches.
// - Interaction between multiple complex data structures.

const GRID_WIDTH: i32 = 50;
const GRID_HEIGHT: i32 = 50;
const NUM_AGENTS: i32 = 20;
const SIMULATION_TICKS: i32 = 100;

const GRID_WIDTH_USIZE: usize = 50;
const GRID_HEIGHT_USIZE: usize = 50;
const NUM_AGENTS_USIZE: usize = 20;

struct Agent {
    id: i32,
    x: i32,
    y: i32,
    energy: i32,
    target_x: i32,
    target_y: i32,
    active: bool,
}

struct World {
    grid: [[i32; GRID_WIDTH_USIZE]; GRID_HEIGHT_USIZE],
    agents: [Agent; NUM_AGENTS_USIZE],
}

fn main() {
    let mut world: World = World {
        grid: [[0; GRID_WIDTH_USIZE]; GRID_HEIGHT_USIZE],
        agents: [Agent {
            id: 0,
            x: 0,
            y: 0,
            energy: 0,
            target_x: 0,
            target_y: 0,
            active: false,
        }; NUM_AGENTS_USIZE],
    };

    initialize_world(&mut world, 98765);

    let mut tick: i32 = 0;
    while (tick < SIMULATION_TICKS) {
        update_world(&mut world);
        process_interactions(&mut world);
        if (tick % 10 == 0) {
            run_diagnostics(&mut world);
        }
        tick = tick + 1;
    }

    final_report(&world);
    printlnInt(9999);
    exit(0);
}

fn initialize_world(world: &mut World, seed: i32) {
    let mut current_seed: i32 = seed;
    let mut i: i32 = 0;
    while (i < NUM_AGENTS) {
        current_seed = (pm_rand_update(current_seed) / 65536) % 32768;
        let x: i32 = current_seed % GRID_WIDTH;
        current_seed = (pm_rand_update(current_seed) / 65536) % 32768;
        let y: i32 = current_seed % GRID_HEIGHT;
        current_seed = (pm_rand_update(current_seed) / 65536) % 32768;
        let energy: i32 = 100 + (current_seed % 100);

        world.agents[i as usize].id = i;
        world.agents[i as usize].x = x;
        world.agents[i as usize].y = y;
        world.agents[i as usize].energy = energy;
        world.agents[i as usize].active = true;
        world.grid[y as usize][x as usize] = i + 1;
        update_agent_target(&mut world.agents[i as usize], current_seed);
        i = i + 1;
    }

    i = 0;
    while (i < GRID_HEIGHT) {
        let mut j: i32 = 0;
        while (j < GRID_WIDTH) {
            if (world.grid[i as usize][j as usize] == 0) {
                current_seed = (pm_rand_update(current_seed) / 65536) % 32768;
                if (current_seed % 10 == 0) {
                    world.grid[i as usize][j as usize] = -1 * (current_seed % 5 + 1);
                }
            }
            j = j + 1;
        }
        i = i + 1;
    }
}

fn update_agent_target(agent: &mut Agent, seed: i32) {
    let mut new_seed: i32 = seed;
    new_seed = (pm_rand_update(new_seed) / 65536) % 32768;
    agent.target_x = new_seed % GRID_WIDTH;
    new_seed = (pm_rand_update(new_seed) / 65536) % 32768;
    agent.target_y = new_seed % GRID_HEIGHT;
}

fn update_world(world: &mut World) {
    let mut i: i32 = 0;
    while (i < NUM_AGENTS) {
        if (world.agents[i as usize].active) {
            let agent: &mut Agent = &mut world.agents[i as usize];
            let old_x: i32 = agent.x;
            let old_y: i32 = agent.y;

            if (agent.x < agent.target_x) {
                agent.x = agent.x + 1;
            } else if (agent.x > agent.target_x) {
                agent.x = agent.x - 1;
            }

            if (agent.y < agent.target_y) {
                agent.y = agent.y + 1;
            } else if (agent.y > agent.target_y) {
                agent.y = agent.y - 1;
            }

            agent.x = clamp(agent.x, 0, GRID_WIDTH - 1);
            agent.y = clamp(agent.y, 0, GRID_HEIGHT - 1);

            agent.energy = agent.energy - 1;

            if (world.grid[(agent.y) as usize][(agent.x) as usize] == 0) {
                world.grid[old_y as usize][old_x as usize] = 0;
                world.grid[(agent.y) as usize][(agent.x) as usize] = agent.id + 1;
            } else {
                agent.x = old_x;
                agent.y = old_y;
                agent.energy = agent.energy - 5;
            }

            if (agent.x == agent.target_x && agent.y == agent.target_y) {
                update_agent_target(agent, agent.id + agent.energy);
            }

            if (agent.energy <= 0) {
                agent.active = false;
                world.grid[(agent.y) as usize][(agent.x) as usize] = 0;
            }
        }
        i = i + 1;
    }
}

fn process_interactions(world: &mut World) {
    let mut i: i32 = 0;
    while (i < NUM_AGENTS) {
        if (!world.agents[i as usize].active) {
            i = i + 1;
            continue;
        }
        let mut j: i32 = i + 1;
        while (j < NUM_AGENTS) {
            if (!world.agents[j as usize].active) {
                j = j + 1;
                continue;
            }

            let agent1: &Agent = &world.agents[i as usize];
            let agent2: &Agent = &world.agents[j as usize];

            let dist_x: i32 = agent1.x - agent2.x;
            let dist_y: i32 = agent1.y - agent2.y;

            if (dist_x * dist_x + dist_y * dist_y < 4) {
                if (agent1.energy > agent2.energy) {
                    world.agents[i as usize].energy = world.agents[i as usize].energy + 10;
                    world.agents[j as usize].energy = world.agents[j as usize].energy - 10;
                } else {
                    world.agents[i as usize].energy = world.agents[i as usize].energy - 10;
                    world.agents[j as usize].energy = world.agents[j as usize].energy + 10;
                }
            }
            j = j + 1;
        }

        let x: i32 = world.agents[i as usize].x;
        let y: i32 = world.agents[i as usize].y;
        if (world.grid[y as usize][x as usize] < 0) {
            world.agents[i as usize].energy =
                world.agents[i as usize].energy + world.grid[y as usize][x as usize] * -10;
            world.grid[y as usize][x as usize] = world.agents[i as usize].id + 1;
        }
        i = i + 1;
    }
}

fn run_diagnostics(world: &mut World) {
    let mut total_energy: i32 = 0;
    let mut active_agents: i32 = 0;
    let mut i: i32 = 0;
    while (i < NUM_AGENTS) {
        if (world.agents[i as usize].active) {
            total_energy = total_energy + world.agents[i as usize].energy;
            active_agents = active_agents + 1;
        }
        i = i + 1;
    }
    printlnInt(100000 + active_agents);
    printlnInt(200000 + total_energy);
    provoke_error(world);
}

fn final_report(world: &World) {
    let mut i: i32 = 0;
    while (i < NUM_AGENTS) {
        if (world.agents[i as usize].active) {
            printlnInt(world.agents[i as usize].id * 10000 + world.agents[i as usize].energy);
        } else {
            printlnInt(world.agents[i as usize].id * 10000 + -1);
        }
        i = i + 1;
    }
}

fn clamp(val: i32, min: i32, max: i32) -> i32 {
    if (val < min) {
        return min;
    }
    if (val > max) {
        return max;
    }
    return val;
}

fn provoke_error(world: &mut World) {
    let mut agent_copy: Agent = world.agents[0];
    agent_copy.energy = -100;

    let mut i: i32 = 0;
    while (i < NUM_AGENTS) {
        if (world.agents[i as usize].active) {
            if (world.agents[i as usize].energy > 150) {
                let mut temp_agent: Agent = world.agents[i as usize];
                temp_agent.energy = temp_agent.energy / 2;
                if (temp_agent.energy > 100) {
                    printlnInt(temp_agent.id + 5000);
                }
            }
        }
        i = i + 1;
    }

    let mut strongest_agent_id: i32 = -1;
    let mut max_energy: i32 = -1;
    i = 0;
    while (i < NUM_AGENTS) {
        if (world.agents[i as usize].active) {
            if (world.agents[i as usize].energy > max_energy) {
                max_energy = world.agents[i as usize].energy;
                strongest_agent_id = world.agents[i as usize].id;
            }
        }
        i = i + 1;
    }

    if (strongest_agent_id != -1) {
        world.agents[strongest_agent_id as usize].energy = 0;
    }
}

fn another_simulation_scenario() {
    let mut world: World = World {
        grid: [[0; GRID_WIDTH_USIZE]; GRID_HEIGHT_USIZE],
        agents: [Agent {
            id: 0,
            x: 0,
            y: 0,
            energy: 0,
            target_x: 0,
            target_y: 0,
            active: false,
        }; NUM_AGENTS_USIZE],
    };
    initialize_world(&mut world, 11223);
    let mut i: i32 = 0;
    while (i < 50) {
        update_world(&mut world);
        i = i + 1;
    }
    process_interactions(&mut world);
    final_report(&world);
}
