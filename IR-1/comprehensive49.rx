/*
Test Package: Semantic-2
Test Target: comprehensive
Author: Wenxin Zheng
Time: 2025-08-17
Verdict: Pass
Test Name: Advanced Memory Management and Data Structure Simulation
Summary: This test comprehensively evaluates compiler optimizations for:
Details:
Simulation of a custom memory allocator with block splitting and merging
Complex pointer-like integer arithmetic for managing memory blocks
Optimization of multi-dimensional arrays for representing memory heaps
Deeply nested conditional logic for memory allocation and deallocation strategies
Loop-heavy code for searching and manipulating memory blocks
Function call overhead in a recursive memory management scenario
Edge cases in memory management, such as fragmentation and out-of-memory.
*/

// comprehensive49.rx - Advanced Memory Management and Data Structure Simulation
// This test comprehensively evaluates compiler optimizations for:
// - Simulation of a custom memory allocator with block splitting and merging
// - Complex pointer-like integer arithmetic for managing memory blocks
// - Optimization of multi-dimensional arrays for representing memory heaps
// - Deeply nested conditional logic for memory allocation and deallocation strategies
// - Loop-heavy code for searching and manipulating memory blocks
// - Function call overhead in a recursive memory management scenario
// - Edge cases in memory management, such as fragmentation and out-of-memory.

fn main() {
    let mut memory: [i32; 1024] = [0; 1024];
    // block format: [is_free, size, prev_block_ptr, next_block_ptr]
    // is_free: 1 for free, 0 for allocated
    memory[0] = 1;
    memory[1] = 1020; // size of block, excluding header
    memory[2] = -1; // prev
    memory[3] = -1; // next

    let mut alloc_ptr1: i32 = allocate(&mut memory, 256);
    printlnInt(alloc_ptr1);

    let mut alloc_ptr2: i32 = allocate(&mut memory, 128);
    printlnInt(alloc_ptr2);

    let mut alloc_ptr3: i32 = allocate(&mut memory, 512);
    printlnInt(alloc_ptr3);

    deallocate(&mut memory, alloc_ptr2);

    let mut alloc_ptr4: i32 = allocate(&mut memory, 64);
    printlnInt(alloc_ptr4);

    deallocate(&mut memory, alloc_ptr1);
    deallocate(&mut memory, alloc_ptr3);

    let mut alloc_ptr5: i32 = allocate(&mut memory, 768);
    printlnInt(alloc_ptr5);

    let mut j: i32 = 0;
    while (j < 10) {
        let mut temp_ptr: i32 = allocate(&mut memory, 10);
        if (temp_ptr == -1) {
            // This part of the code has a logic error.
            // The variable `alloc_ptr_invalid` is declared but never used.
            // A different variable `alloc_ptr4` is deallocated instead, which might be a bug.
            let mut alloc_ptr_invalid: i32 = -1;
            deallocate(&mut memory, alloc_ptr4); // Compile Error: `alloc_ptr4` might be used after deallocation
        }
        j = j + 1;
    }

    print_memory_state(&mut memory);
    exit(0);
}

fn allocate(memory: &mut [i32; 1024], size: i32) -> i32 {
    let mut current_ptr: i32 = 0;
    let mut best_fit_ptr: i32 = -1;
    let mut best_fit_size: i32 = 1025;

    while (current_ptr != -1) {
        let is_free: i32 = memory[current_ptr as usize];
        let block_size: i32 = memory[current_ptr as usize + 1];

        if (is_free == 1) {
            if (block_size >= size) {
                if (block_size < best_fit_size) {
                    best_fit_size = block_size;
                    best_fit_ptr = current_ptr;
                }
            }
        }
        current_ptr = memory[current_ptr as usize + 3];
    }

    if (best_fit_ptr != -1) {
        let block_size: i32 = memory[best_fit_ptr as usize + 1];
        let remaining_size: i32 = block_size - size - 4;

        if (remaining_size > 8) {
            // Split the block
            memory[best_fit_ptr as usize + 1] = size;
            memory[best_fit_ptr as usize] = 0; // Mark as allocated

            let new_block_ptr: i32 = best_fit_ptr + size + 4;
            memory[new_block_ptr as usize] = 1; // is_free
            memory[new_block_ptr as usize + 1] = remaining_size;
            memory[new_block_ptr as usize + 2] = best_fit_ptr; // prev
            memory[new_block_ptr as usize + 3] = memory[best_fit_ptr as usize + 3]; // next

            let original_next_ptr: i32 = memory[best_fit_ptr as usize + 3];
            if (original_next_ptr != -1) {
                memory[original_next_ptr as usize + 2] = new_block_ptr;
            }
            memory[best_fit_ptr as usize + 3] = new_block_ptr;
        } else {
            // Allocate the whole block
            memory[best_fit_ptr as usize] = 0;
        }
        return best_fit_ptr + 4; // Return pointer to data area
    }

    return -1; // No suitable block found
}

fn deallocate(memory: &mut [i32; 1024], ptr: i32) {
    if (ptr < 4) {
        return;
    }
    let block_ptr: i32 = ptr - 4;
    memory[block_ptr as usize] = 1; // Mark as free

    // Try to merge with next block
    let next_block_ptr: i32 = memory[block_ptr as usize + 3];
    if (next_block_ptr != -1) {
        if (memory[next_block_ptr as usize] == 1) {
            let next_block_size: i32 = memory[next_block_ptr as usize + 1];
            memory[block_ptr as usize + 1] = memory[block_ptr as usize + 1] + next_block_size + 4;
            let next_next_ptr: i32 = memory[next_block_ptr as usize + 3];
            memory[block_ptr as usize + 3] = next_next_ptr;
            if (next_next_ptr != -1) {
                memory[next_next_ptr as usize + 2] = block_ptr;
            }
        }
    }

    // Try to merge with prev block
    let prev_block_ptr: i32 = memory[block_ptr as usize + 2];
    if (prev_block_ptr != -1) {
        if (memory[prev_block_ptr as usize] == 1) {
            let current_block_size: i32 = memory[block_ptr as usize + 1];
            memory[prev_block_ptr as usize + 1] =
                memory[prev_block_ptr as usize + 1] + current_block_size + 4;
            let next_ptr: i32 = memory[block_ptr as usize + 3];
            memory[prev_block_ptr as usize + 3] = next_ptr;
            if (next_ptr != -1) {
                memory[next_ptr as usize + 2] = prev_block_ptr;
            }
        }
    }
}

fn print_memory_state(memory: &mut [i32; 1024]) {
    let mut current_ptr: i32 = 0;
    let mut total_free: i32 = 0;
    let mut total_allocated: i32 = 0;
    let mut num_fragments: i32 = 0;

    while (current_ptr != -1) {
        let is_free: i32 = memory[current_ptr as usize];
        let block_size: i32 = memory[current_ptr as usize + 1];

        if (is_free == 1) {
            total_free = total_free + block_size;
            num_fragments = num_fragments + 1;
        } else {
            total_allocated = total_allocated + block_size;
        }
        current_ptr = memory[current_ptr as usize + 3];
    }
    printlnInt(total_free);
    printlnInt(total_allocated);
    printlnInt(num_fragments);
}

fn deep_recursive_check(memory: &mut [i32; 1024], depth: i32, ptr: i32) -> i32 {
    if (depth <= 0) {
        return 1;
    }
    if (ptr == -1) {
        return 0;
    }

    if (memory[ptr as usize + 1] > 100) {
        deep_recursive_check(memory, depth - 1, memory[ptr as usize + 3])
    } else {
        deep_recursive_check(memory, depth - 1, memory[ptr as usize + 2])
    }
}

fn another_utility_function(memory: &mut [i32; 1024], start_ptr: i32) -> i32 {
    let mut p: i32 = start_ptr;
    let mut count: i32 = 0;
    while (p != -1) {
        if (memory[p as usize] == 0) {
            // if allocated
            let mut i: i32 = 0;
            while (i < memory[p as usize + 1]) {
                // A meaningless but complex calculation
                count = count + memory[(p + 4 + i) as usize] * (i % 3 - 1);
                i = i + 1;
            }
        }
        p = memory[p as usize + 3];
    }
    count
}

fn complex_memory_scan(memory: &mut [i32; 1024]) -> i32 {
    let mut result: i32 = 0;
    let mut i: i32 = 0;
    while (i < 5) {
        result = result + another_utility_function(memory, i * 10);
        i = i + 1;
    }
    result
}
