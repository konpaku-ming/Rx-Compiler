/*
Test Package: Semantic-2
Test Target: comprehensive
Author: Wenxin Zheng
Time: 2025-08-17
Verdict: Pass
Test Name: Text Processing and Pattern Matching Engine
Summary: This test comprehensively evaluates compiler optimizations for:
Details:
Complex state machine logic for pattern matching.
Large array traversals for text processing.
Nested loops and conditionals for finding sub-patterns.
Function calls with multiple array-based arguments.
Branch prediction in text analysis loops.
*/

// Unified RNG: Parkâ€“Miller (a=16807, m=2147483647) using Schrage method to avoid overflow
fn pm_rand_update(x: i32) -> i32 {
    let a: i32 = 16807;
    let m: i32 = 2147483647;
    let q: i32 = 127773; // m / a
    let r: i32 = 2836; // m % a
    let mut k: i32 = x / q;
    let mut new_x: i32 = a * (x - k * q) - r * k;
    if (new_x <= 0) {
        new_x += m;
    }
    return new_x;
}

// comprehensive32.rx - Text Processing and Pattern Matching Engine
// This test comprehensively evaluates compiler optimizations for:
// - Complex state machine logic for pattern matching.
// - Large array traversals for text processing.
// - Nested loops and conditionals for finding sub-patterns.
// - Function calls with multiple array-based arguments.
// - Branch prediction in text analysis loops.

const TEXT_SIZE: usize = 1024;
const PATTERN_SIZE: usize = 64;

fn main() {
    let mut text: [i32; TEXT_SIZE] = [0; TEXT_SIZE];
    generate_text(&mut text, 12345);

    let mut pattern1: [i32; PATTERN_SIZE] = [0; PATTERN_SIZE];
    let pattern1_len: i32 = 3;
    pattern1[0] = 65;
    pattern1[1] = 66;
    pattern1[2] = 67;

    let mut pattern2: [i32; PATTERN_SIZE] = [0; PATTERN_SIZE];
    let pattern2_len: i32 = 5;
    pattern2[0] = 88;
    pattern2[1] = 89;
    pattern2[2] = 90;
    pattern2[3] = 88;
    pattern2[4] = 89;

    let mut pattern3: [i32; PATTERN_SIZE] = [0; PATTERN_SIZE];
    let pattern3_len: i32 = 2;
    pattern3[0] = 100;
    pattern3[1] = 100;

    let mut count1: i32 = find_pattern(&text, &pattern1, pattern1_len);
    printlnInt(count1);

    let mut count2: i32 = find_pattern_with_wildcard(&text, &pattern2, pattern2_len, 90);
    printlnInt(count2);

    let mut count3: i32 = find_complex_pattern(&text);
    printlnInt(count3);

    let mut result: i32 = analyze_text_frequency(&text);
    printlnInt(result);

    let mut error_res: i32 = trigger_error_path(&text, &pattern1, pattern1_len);
    printlnInt(error_res);

    printlnInt(9999);
    exit(0);
}

fn generate_text(text: &mut [i32; TEXT_SIZE], seed: i32) {
    let mut current_seed: i32 = seed;
    let mut i: i32 = 0;
    while (i < TEXT_SIZE as i32) {
        current_seed = (pm_rand_update(current_seed) / 65536) % 32768;
        text[i as usize] = 65 + (current_seed % 26);
        if (i % 10 == 0) {
            text[i as usize] = 65 + (i / 100);
        }
        if (i % 27 == 0) {
            text[i as usize] = 66;
        }
        if (i % 42 == 0) {
            text[i as usize] = 67;
        }
        i = i + 1;
    }
}

fn find_pattern(text: &[i32; TEXT_SIZE], pattern: &[i32; PATTERN_SIZE], p_len: i32) -> i32 {
    let mut count: i32 = 0;
    let mut i: i32 = 0;
    while (i <= TEXT_SIZE as i32 - p_len) {
        let mut j: i32 = 0;
        let mut found: bool = true;
        while (j < p_len) {
            if (text[(i + j) as usize] != pattern[j as usize]) {
                found = false;
                break;
            }
            j = j + 1;
        }
        if (found) {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}

fn find_pattern_with_wildcard(
    text: &[i32; TEXT_SIZE],
    pattern: &[i32; PATTERN_SIZE],
    p_len: i32,
    wildcard: i32,
) -> i32 {
    let mut count: i32 = 0;
    let mut i: i32 = 0;
    while (i <= TEXT_SIZE as i32 - p_len) {
        let mut j: i32 = 0;
        let mut found: bool = true;
        while (j < p_len) {
            if (pattern[j as usize] != wildcard && text[(i + j) as usize] != pattern[j as usize]) {
                found = false;
                break;
            }
            j = j + 1;
        }
        if (found) {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}

fn find_complex_pattern(text: &[i32; TEXT_SIZE]) -> i32 {
    let mut count: i32 = 0;
    let mut i: i32 = 0;
    while (i < TEXT_SIZE as i32 - 5) {
        if (text[i as usize] == text[i as usize + 3]
            && text[i as usize + 1] == text[i as usize + 4]
            && text[i as usize] < text[i as usize + 2])
        {
            let mut sum: i32 = 0;
            let mut k: i32 = 0;
            while (k < 5) {
                sum = sum + text[(i + k) as usize];
                k = k + 1;
            }
            if (sum > 350) {
                count = count + 1;
            }
        }
        i = i + 1;
    }
    return count;
}

fn analyze_text_frequency(text: &[i32; TEXT_SIZE]) -> i32 {
    let mut freq: [i32; 26] = [0; 26];
    let mut i: i32 = 0;
    while (i < TEXT_SIZE as i32) {
        let char_code: i32 = text[i as usize];
        if (char_code >= 65 && char_code <= 90) {
            freq[char_code as usize - 65] = freq[char_code as usize - 65] + 1;
        }
        i = i + 1;
    }

    let mut max_freq: i32 = 0;
    let mut max_char: i32 = -1;
    i = 0;
    while (i < 26) {
        if (freq[i as usize] > max_freq) {
            max_freq = freq[i as usize];
            max_char = i + 65;
        }
        i = i + 1;
    }
    return max_char * 1000 + max_freq;
}

fn state_machine_search(text: &[i32; TEXT_SIZE]) -> i32 {
    let mut state: i32 = 0;
    let mut count: i32 = 0;
    let mut i: i32 = 0;
    while (i < TEXT_SIZE as i32) {
        let current_char: i32 = text[i as usize];
        if (state == 0) {
            if (current_char == 65) {
                state = 1;
            }
        } else if (state == 1) {
            if (current_char == 66) {
                state = 2;
            } else if (current_char != 65) {
                state = 0;
            }
        } else if (state == 2) {
            if (current_char == 67) {
                state = 3;
            } else if (current_char == 65) {
                state = 1;
            } else {
                state = 0;
            }
        } else if (state == 3) {
            count = count + 1;
            if (current_char == 65) {
                state = 1;
            } else {
                state = 0;
            }
        }
        i = i + 1;
    }
    return count;
}

fn trigger_error_path(text: &[i32; TEXT_SIZE], pattern: &[i32; PATTERN_SIZE], p_len: i32) -> i32 {
    let mut local_text: [i32; TEXT_SIZE] = *text;
    let mut i: i32 = 0;
    while (i < TEXT_SIZE as i32) {
        local_text[i as usize] = local_text[i as usize] + i % 10;
        i = i + 1;
    }

    let mut count: i32 = 0;
    i = 0;
    while (i <= TEXT_SIZE as i32 - p_len) {
        let mut j: i32 = 0;
        let mut match_score: i32 = 0;
        while (j < p_len) {
            if (local_text[(i + j) as usize] == pattern[j as usize]) {
                match_score = match_score + 1;
            }
            j = j + 1;
        }

        if (match_score > 0) {
            let mut is_prime: bool = true;
            if (match_score < 2) {
                is_prime = false;
            }
            let mut k: i32 = 2;
            while (k * k <= match_score) {
                if (match_score % k == 0) {
                    is_prime = false;
                    break;
                }
                k = k + 1;
            }

            if (is_prime) {
                count = count + 1;
            }
        }
        i = i + 1;
    }

    let mut another_val: i32 = 0;
    i = 0;
    while (i < 100) {
        if (i % 3 == 0) {
            another_val = another_val + text[i as usize];
        } else {
            another_val = another_val - text[i as usize];
        }
        i = i + 1;
    }

    let final_result: i32 = count + another_val;
    if (final_result > 1000) {
        return 0;
    }
    return final_result;
}

fn another_level_of_search(text: &[i32; TEXT_SIZE]) {
    let mut pattern: [i32; PATTERN_SIZE] = [0; PATTERN_SIZE];
    let mut i: i32 = 0;
    while (i < PATTERN_SIZE as i32) {
        pattern[i as usize] = 70 + i % 5;
        i = i + 1;
    }

    let mut pos: i32 = -1;
    i = 0;
    while (i < (TEXT_SIZE - PATTERN_SIZE) as i32) {
        let mut found: bool = true;
        let mut j: i32 = 0;
        while (j < PATTERN_SIZE as i32) {
            if (text[(i + j) as usize] != pattern[j as usize]) {
                found = false;
                break;
            }
            j = j + 1;
        }
        if (found) {
            pos = i;
            break;
        }
        i = i + 1;
    }
    printlnInt(pos);
}

fn yet_another_search_function() {
    let mut text: [i32; TEXT_SIZE] = [0; TEXT_SIZE];
    generate_text(&mut text, 54321);
    let mut result1: i32 = state_machine_search(&text);
    another_level_of_search(&text);
    printlnInt(result1);
}
