/*
Test Package: Semantic-2
Test Target: comprehensive
Author: Wenxin Zheng
Time: 2025-08-17
Verdict: Pass
Test Name: Simple Virtual Machine Interpreter
Summary: This test comprehensively evaluates compiler optimizations for:
Details:
Large switch-like control flow (if-else-if (chains) for opcode dispatch.)
Array-based stack and instruction memory manipulation.
Loop optimization for the main fetch-decode-execute cycle.
Integer arithmetic and logical operations within a simulated environment.
Function call overhead for modularized VM components.
Branch prediction in the context of a VM's conditional jumps.
Mutability tracking and potential conflicts in VM state management.
*/

// comprehensive37.rx - Simple Virtual Machine Interpreter
// This test comprehensively evaluates compiler optimizations for:
// - Large switch-like control flow (if-else-if chains) for opcode dispatch.
// - Array-based stack and instruction memory manipulation.
// - Loop optimization for the main fetch-decode-execute cycle.
// - Integer arithmetic and logical operations within a simulated environment.
// - Function call overhead for modularized VM components.
// - Branch prediction in the context of a VM's conditional jumps.
// - Mutability tracking and potential conflicts in VM state management.

const MEMORY_SIZE: i32 = 1024;
const STACK_SIZE: i32 = 256;

const HALT: i32 = 0;
const PUSH: i32 = 1;
const POP: i32 = 2;
const ADD: i32 = 3;
const SUB: i32 = 4;
const MUL: i32 = 5;
const DIV: i32 = 6;
const PRINT: i32 = 7;
const JMP: i32 = 8;
const JZ: i32 = 9;
const JNZ: i32 = 10;
const EQ: i32 = 11;
const LT: i32 = 12;
const STORE: i32 = 13;
const LOAD: i32 = 14;
const DUP: i32 = 15;

fn push_stack(stack: &mut [i32; 256], sp: &mut i32, val: i32) {
    if (*sp < STACK_SIZE - 1) {
        *sp = *sp + 1;
        stack[*sp as usize] = val;
    }
}

fn pop_stack(stack: &[i32; 256], sp: &mut i32) -> i32 {
    if (*sp > -1) {
        let val: i32 = stack[*sp as usize];
        *sp = *sp - 1;
        return val;
    }
    return 0;
}

fn load_program(memory: &mut [i32; 1024]) {
    let mut i: i32 = 0;

    memory[i as usize] = PUSH; i = i + 1;
    memory[i as usize] = 10; i = i + 1;
    memory[i as usize] = STORE; i = i + 1;
    memory[i as usize] = 256; i = i + 1;

    memory[i as usize] = PUSH; i = i + 1;
    memory[i as usize] = 1; i = i + 1;
    memory[i as usize] = STORE; i = i + 1;
    memory[i as usize] = 257; i = i + 1;

    memory[i as usize] = PUSH; i = i + 1;
    memory[i as usize] = 1; i = i + 1;
    memory[i as usize] = STORE; i = i + 1;
    memory[i as usize] = 258; i = i + 1;

    let loop_start: i32 = i;
    memory[i as usize] = LOAD; i = i + 1;
    memory[i as usize] = 256; i = i + 1;
    memory[i as usize] = PUSH; i = i + 1;
    memory[i as usize] = 1; i = i + 1;
    memory[i as usize] = SUB; i = i + 1;
    memory[i as usize] = DUP; i = i + 1;
    memory[i as usize] = STORE; i = i + 1;
    memory[i as usize] = 256; i = i + 1;
    memory[i as usize] = JZ; i = i + 1;
    memory[i as usize] = 50; i = i + 1;

    memory[i as usize] = LOAD; i = i + 1;
    memory[i as usize] = 257; i = i + 1;
    memory[i as usize] = LOAD; i = i + 1;
    memory[i as usize] = 258; i = i + 1;
    memory[i as usize] = ADD; i = i + 1;
    memory[i as usize] = DUP; i = i + 1;
    memory[i as usize] = STORE; i = i + 1;
    memory[i as usize] = 257; i = i + 1;
    memory[i as usize] = POP; i = i + 1;
    memory[i as usize] = LOAD; i = i + 1;
    memory[i as usize] = 257; i = i + 1;
    memory[i as usize] = STORE; i = i + 1;
    memory[i as usize] = 258; i = i + 1;

    memory[i as usize] = JMP; i = i + 1;
    memory[i as usize] = loop_start; i = i + 1;

    memory[i as usize] = LOAD; i = i + 1;
    memory[i as usize] = 258; i = i + 1;
    memory[i as usize] = PRINT; i = i + 1;
    memory[i as usize] = HALT; i = i + 1;

    let mut j: i32 = 0;
    while (j < 20) {
        let k: i32 = 100 + j * 10;
        memory[k as usize] = PUSH;
        memory[k as usize+1] = j;
        memory[k as usize+2] = PUSH;
        memory[k as usize+3] = j + 1;
        memory[k as usize+4] = MUL;
        memory[k as usize+5] = PRINT;
        memory[k as usize+6] = POP;
        j = j + 1;
    }
    memory[99] = JMP;
    memory[100] = 100;

    let mut factorial_addr: i32 = 400;
    memory[factorial_addr as usize] = STORE; factorial_addr = factorial_addr + 1;
    memory[factorial_addr as usize] = 500; factorial_addr = factorial_addr + 1;
    memory[factorial_addr as usize] = LOAD; factorial_addr = factorial_addr + 1;
    memory[factorial_addr as usize] = 500; factorial_addr = factorial_addr + 1;
    memory[factorial_addr as usize] = PUSH; factorial_addr = factorial_addr + 1;
    memory[factorial_addr as usize] = 1; factorial_addr = factorial_addr + 1;
    memory[factorial_addr as usize] = LT; factorial_addr = factorial_addr + 1;
    memory[factorial_addr as usize] = JZ; factorial_addr = factorial_addr + 1;
    memory[factorial_addr as usize] = factorial_addr + 12; factorial_addr = factorial_addr + 1;
    memory[factorial_addr as usize] = PUSH; factorial_addr = factorial_addr + 1;
    memory[factorial_addr as usize] = 1; factorial_addr = factorial_addr + 1;
    memory[factorial_addr as usize] = JMP; factorial_addr = factorial_addr + 1;
    memory[factorial_addr as usize] = 500;

    memory[factorial_addr as usize] = LOAD; factorial_addr = factorial_addr + 1;
    memory[factorial_addr as usize] = 500; factorial_addr = factorial_addr + 1;
    memory[factorial_addr as usize] = PUSH; factorial_addr = factorial_addr + 1;
    memory[factorial_addr as usize] = 1; factorial_addr = factorial_addr + 1;
    memory[factorial_addr as usize] = SUB; factorial_addr = factorial_addr + 1;
    memory[factorial_addr as usize] = JMP;
    memory[factorial_addr as usize] = 400;

    let mut fib_addr: i32 = 600;
    memory[fib_addr as usize] = STORE; fib_addr = fib_addr + 1;
    memory[fib_addr as usize] = 700; fib_addr = fib_addr + 1;
    memory[fib_addr as usize] = LOAD; fib_addr = fib_addr + 1;
    memory[fib_addr as usize] = 700; fib_addr = fib_addr + 1;
    memory[fib_addr as usize] = PUSH; fib_addr = fib_addr + 1;
    memory[fib_addr as usize] = 2; fib_addr = fib_addr + 1;
    memory[fib_addr as usize] = LT; fib_addr = fib_addr + 1;
    memory[fib_addr as usize] = JZ; fib_addr = fib_addr + 1;
    memory[fib_addr as usize] = fib_addr + 4; fib_addr = fib_addr + 1;
    memory[fib_addr as usize] = LOAD; fib_addr = fib_addr + 1;
    memory[fib_addr as usize] = 700; fib_addr = fib_addr + 1;
    memory[fib_addr as usize] = JMP; fib_addr = fib_addr + 1;
    memory[fib_addr as usize] = 800;

    memory[fib_addr as usize] = LOAD; fib_addr = fib_addr + 1;
    memory[fib_addr as usize] = 700; fib_addr = fib_addr + 1;
    memory[fib_addr as usize] = PUSH; fib_addr = fib_addr + 1;
    memory[fib_addr as usize] = 1; fib_addr = fib_addr + 1;
    memory[fib_addr as usize] = SUB; fib_addr = fib_addr + 1;
    memory[fib_addr as usize] = JMP; fib_addr = fib_addr + 1;
    memory[fib_addr as usize] = 600; fib_addr = fib_addr + 1;

    memory[fib_addr as usize] = LOAD; fib_addr = fib_addr + 1;
    memory[fib_addr as usize] = 700; fib_addr = fib_addr + 1;
    memory[fib_addr as usize] = PUSH; fib_addr = fib_addr + 1;
    memory[fib_addr as usize] = 2; fib_addr = fib_addr + 1;
    memory[fib_addr as usize] = SUB; fib_addr = fib_addr + 1;
    memory[fib_addr as usize] = JMP; fib_addr = fib_addr + 1;
    memory[fib_addr as usize] = 600; fib_addr = fib_addr + 1;

    memory[fib_addr as usize] = ADD; fib_addr = fib_addr + 1;
    memory[fib_addr as usize] = JMP; fib_addr = fib_addr + 1;
    memory[fib_addr as usize] = 800;
}

fn execute_cycle(memory: &mut [i32; 1024], pc: &mut i32, stack: &mut [i32; 256], sp: &mut i32, running: &mut bool) {
    let instruction: i32 = memory[*pc as usize];
    *pc = *pc + 1;

    if (instruction == HALT) {
        *running = false;
    } else if (instruction == PUSH) {
        let value: i32 = memory[*pc as usize];
        *pc = *pc + 1;
        push_stack(stack, sp, value);
    } else if (instruction == POP) {
        pop_stack(stack, sp);
    } else if (instruction == ADD) {
        let b: i32 = pop_stack(stack, sp);
        let a: i32 = pop_stack(stack, sp);
        push_stack(stack, sp, a + b);
    } else if (instruction == SUB) {
        let b: i32 = pop_stack(stack, sp);
        let a: i32 = pop_stack(stack, sp);
        push_stack(stack, sp, a - b);
    } else if (instruction == MUL) {
        let b: i32 = pop_stack(stack, sp);
        let a: i32 = pop_stack(stack, sp);
        push_stack(stack, sp, a * b);
    } else if (instruction == DIV) {
        let b: i32 = pop_stack(stack, sp);
        let a: i32 = pop_stack(stack, sp);
        if (b != 0) {
            push_stack(stack, sp, a / b);
        } else {
            *running = false;
        }
    } else if (instruction == PRINT) {
        let val: i32 = pop_stack(stack, sp);
        printlnInt(val);
    } else if (instruction == JMP) {
        *pc = memory[*pc as usize];
    } else if (instruction == JZ) {
        let val: i32 = pop_stack(stack, sp);
        if (val == 0) {
            *pc = memory[*pc as usize];
        } else {
            *pc = *pc + 1;
        }
    } else if (instruction == JNZ) {
        let val: i32 = pop_stack(stack, sp);
        if (val != 0) {
            *pc = memory[*pc as usize];
        } else {
            *pc = *pc + 1;
        }
    } else if (instruction == EQ) {
        let b: i32 = pop_stack(stack, sp);
        let a: i32 = pop_stack(stack, sp);
        if (a == b) {
            push_stack(stack, sp, 1);
        } else {
            push_stack(stack, sp, 0);
        }
    } else if (instruction == LT) {
        let b: i32 = pop_stack(stack, sp);
        let a: i32 = pop_stack(stack, sp);
        if (a < b) {
            push_stack(stack, sp, 1);
        } else {
            push_stack(stack, sp, 0);
        }
    } else if (instruction == STORE) {
        let addr: i32 = memory[*pc as usize];
        *pc = *pc + 1;
        let val: i32 = pop_stack(stack, sp);
        memory[addr as usize] = val;
    } else if (instruction == LOAD) {
        let addr: i32 = memory[*pc as usize];
        *pc = *pc + 1;
        let val: i32 = memory[addr as usize];
        push_stack(stack, sp, val);
    } else if (instruction == DUP) {
        let val: i32 = stack[*sp as usize];
        push_stack(stack, sp, val);
    }
}

fn main() {
    let mut memory: [i32; 1024] = [0; 1024];
    let mut stack: [i32; 256] = [0; 256];
    let mut pc: i32 = 0;
    let mut sp: i32 = -1;
    let mut running: bool = true;
    load_program(&mut memory);

    let mut cycle_count: i32 = 0;
    let max_cycles: i32 = 5000;

    while (running) {
        if (cycle_count > max_cycles) {
            break;
        }
        execute_cycle(&mut memory, &mut pc, &mut stack, &mut sp, &mut running);
        cycle_count = cycle_count + 1;
    }

    printlnInt(cycle_count);
    printlnInt(sp);

    let mut i: i32 = 0;
    let mut checksum: i32 = 0;
    while (i < STACK_SIZE) {
        checksum = checksum + stack[i as usize];
        i = i + 1;
    }
    printlnInt(checksum);

    pc = 100;
    sp = -1;
    running = true;
    cycle_count = 0;
    while (running) {
        if (cycle_count > 100) {
            break;
        }
        execute_cycle(&mut memory, &mut pc, &mut stack, &mut sp, &mut running);
        cycle_count = cycle_count + 1;
    }

    let mut vm_state: i32 = 1;
    let mut i: i32 = 0;
    while (i < 10) {
        let vm_state: i32 = vm_state + i;
        i = i + 1;
    }
    printlnInt(vm_state);
    exit(0);
}
