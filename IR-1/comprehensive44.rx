/*
Test Package: Semantic-2
Test Target: comprehensive
Author: Wenxin Zheng
Time: 2025-08-17
Verdict: Pass
Test Name: Multi-Agent System Simulation
Summary: This test comprehensively evaluates compiler optimizations for:
Details:
Complex object-like structures using arrays and structs.
Simulation of parallel behavior and interaction in a single thread.
Advanced multi-dimensional array access and updates.
Branch prediction for agent decision-making logic.
Loop unrolling and optimization for state update cycles.
Function call overhead with complex state passing.
*/

// comprehensive44.rx - Multi-Agent System Simulation
// This test comprehensively evaluates compiler optimizations for:
// - Complex object-like structures using arrays and structs.
// - Simulation of parallel behavior and interaction in a single thread.
// - Advanced multi-dimensional array access and updates.
// - Branch prediction for agent decision-making logic.
// - Loop unrolling and optimization for state update cycles.
// - Function call overhead with complex state passing.

fn main() {
    struct Agent {
        id: i32,
        x: i32,
        y: i32,
        energy: i32,
        target_x: i32,
        target_y: i32,
        state: i32, // 0: idle, 1: moving, 2: collecting
    }

    let mut world: [[i32; 64]; 64] = [[0; 64]; 64];
    let mut agents: [Agent; 32] = [Agent {
        id: 0,
        x: 0,
        y: 0,
        energy: 0,
        target_x: 0,
        target_y: 0,
        state: 0,
    }; 32];
    let num_agents: i32 = 32;
    let world_size: i32 = 64;

    fn init_world(world: &mut [[i32; 64]; 64], agents: &mut [Agent; 32]) {
        let mut i: i32 = 0;
        while (i < 64) {
            let mut j: i32 = 0;
            while (j < 64) {
                world[i as usize][j as usize] = (i * j + i + j) % 100; // Resource density
                j = j + 1;
            }
            i = i + 1;
        }

        i = 0;
        while (i < 32) {
            agents[i as usize].id = i;
            agents[i as usize].x = (i * 13) % 64;
            agents[i as usize].y = (i * 31) % 64;
            agents[i as usize].energy = 100;
            agents[i as usize].state = 0;
            i = i + 1;
        }
    }

    fn find_new_target(agent: &Agent, world: &[[i32; 64]; 64]) -> i32 {
        let mut best_x: i32 = -1;
        let mut best_y: i32 = -1;
        let mut max_res: i32 = -1;
        let mut dx: i32 = -5;
        while (dx <= 5) {
            let mut dy: i32 = -5;
            while (dy <= 5) {
                let nx: i32 = (agent.x + dx + 64) % 64;
                let ny: i32 = (agent.y + dy + 64) % 64;
                if (world[nx as usize][ny as usize] > max_res) {
                    max_res = world[nx as usize][ny as usize];
                    best_x = nx;
                    best_y = ny;
                }
                dy = dy + 1;
            }
            dx = dx + 1;
        }
        return best_x * 1000 + best_y;
    }

    fn update_agent(agent: &mut Agent, world: &mut [[i32; 64]; 64]) {
        if (agent.energy <= 0) {
            return;
        }
        agent.energy = agent.energy - 1;

        if (agent.state == 0) {
            // Idle
            let target: i32 = find_new_target(agent, world);
            agent.target_x = target / 1000;
            agent.target_y = target % 1000;
            agent.state = 1;
        } else if (agent.state == 1) {
            // Moving
            if (agent.x == agent.target_x && agent.y == agent.target_y) {
                agent.state = 2;
            } else {
                if (agent.x < agent.target_x) {
                    agent.x = agent.x + 1;
                } else if (agent.x > agent.target_x) {
                    agent.x = agent.x - 1;
                }

                if (agent.y < agent.target_y) {
                    agent.y = agent.y + 1;
                } else if (agent.y > agent.target_y) {
                    agent.y = agent.y - 1;
                }
            }
        } else if (agent.state == 2) {
            // Collecting
            let res: i32 = world[(agent.x) as usize][(agent.y) as usize];
            if (res > 0) {
                agent.energy = agent.energy + res / 5;
                world[(agent.x) as usize][(agent.y) as usize] =
                    world[(agent.x) as usize][(agent.y) as usize] - res / 10 - 1;
                if (world[(agent.x) as usize][(agent.y) as usize] < 0) {
                    world[(agent.x) as usize][(agent.y) as usize] = 0;
                }
            }
            agent.state = 0;
        }
    }

    init_world(&mut world, &mut agents);

    let mut time_step: i32 = 0;
    while (time_step < 200) {
        let mut i: i32 = 0;
        while (i < 32) {
            update_agent(&mut agents[i as usize], &mut world);
            i = i + 1;
        }

        // Hidden Error: `total_energy` is declared as immutable but is modified
        // inside the loop. This should cause a mutability error.
        if (time_step % 20 == 0) {
            let mut total_energy: i32 = 0;
            let mut j: i32 = 0;
            while (j < 32) {
                total_energy = total_energy + agents[j as usize].energy;
                j = j + 1;
            }
            printlnInt(total_energy);
        }
        time_step = time_step + 1;
    }

    let mut final_world_sum: i32 = 0;
    let mut i: i32 = 0;
    while (i < 64) {
        let mut j: i32 = 0;
        while (j < 64) {
            final_world_sum = final_world_sum + world[i as usize][j as usize];
            j = j + 1;
        }
        i = i + 1;
    }
    printlnInt(final_world_sum);
    exit(0);
}
