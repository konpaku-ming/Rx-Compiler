/*
Test Package: Semantic-2
Test Target: comprehensive
Author: Wenxin Zheng
Time: 2025-08-17
Verdict: Pass
Test Name: Genetic Algorithm for Optimization
Summary: This test comprehensively evaluates compiler optimizations for:
Details:
Simulation of evolutionary processes with selection, crossover, and mutation.
Complex fitness function calculations involving non-linear operations.
Management of a population of candidate solutions (large array of structs).
Random number generation and its impact on control flow.
Loop-heavy operations for evaluating and evolving the population.
Re-use of variables with different meanings in different scopes.
*/

// comprehensive47.rx - Genetic Algorithm for Optimization
// This test comprehensively evaluates compiler optimizations for:
// - Simulation of evolutionary processes with selection, crossover, and mutation.
// - Complex fitness function calculations involving non-linear operations.
// - Management of a population of candidate solutions (large array of structs).
// - Random number generation and its impact on control flow.
// - Loop-heavy operations for evaluating and evolving the population.
// - Re-use of variables with different meanings in different scopes.

fn main() {
    struct Chromosome {
        genes: [i32; 16],
        fitness: i32,
    }

    let mut population: [Chromosome; 64] = [Chromosome {
        genes: [0; 16],
        fitness: 0,
    }; 64];
    let mut rng_seed: i32 = 12345;

    fn pseudo_rand(seed: &mut i32) -> i32 {
        *seed = (*seed * 127 + 16777337) & 16777215;
        return *seed;
    }

    fn init_population(pop: &mut [Chromosome; 64], seed: &mut i32) {
        let mut i: usize = 0;
        while (i < 64) {
            let mut j: usize = 0;
            while (j < 16) {
                pop[i as usize].genes[j as usize] = pseudo_rand(seed) % 200 - 100;
                j = j + 1;
            }
            i = i + 1;
        }
    }

    // Fitness function: try to make genes sum to a target, with penalties
    fn calculate_fitness(chrom: &mut Chromosome) {
        let target_sum: i32 = 500;
        let mut sum: i32 = 0;
        let mut penalty: i32 = 0;
        let mut i: usize = 0;
        while (i < 16) {
            sum = sum + chrom.genes[i as usize];
            if (chrom.genes[i as usize] > 90 || chrom.genes[i as usize] < -90) {
                penalty = penalty + (chrom.genes[i as usize] * chrom.genes[i as usize]);
            }
            i = i + 1;
        }
        let diff: i32 = target_sum - sum;
        chrom.fitness = -(diff * diff) - penalty; // Maximize fitness (closer to 0 is better)
    }

    fn evaluate_population(pop: &mut [Chromosome; 64]) {
        let mut i: usize = 0;
        while (i < 64) {
            calculate_fitness(&mut pop[i as usize]);
            i = i + 1;
        }
    }

    fn selection(pop: &[Chromosome; 64], seed: &mut i32) -> i32 {
        let tournament_size: i32 = 5;
        let mut best_index: i32 = -1;
        let mut best_fitness: i32 = -99999999;
        let mut i: i32 = 0;
        while (i < tournament_size) {
            let idx: usize = pseudo_rand(seed) as usize % 64;
            if (pop[idx as usize].fitness > best_fitness) {
                best_fitness = pop[idx as usize].fitness;
                best_index = idx as i32;
            }
            i = i + 1;
        }
        return best_index;
    }

    fn crossover(
        parent1: &Chromosome,
        parent2: &Chromosome,
        child: &mut Chromosome,
        seed: &mut i32,
    ) {
        let crossover_point: i32 = pseudo_rand(seed) % 16;
        let mut i: usize = 0;
        while (i < 16) {
            if (i < crossover_point as usize) {
                child.genes[i as usize] = parent1.genes[i as usize];
            } else {
                child.genes[i as usize] = parent2.genes[i as usize];
            }
            i = i + 1;
        }
    }

    fn mutate(chrom: &mut Chromosome, seed: &mut i32) {
        let mutation_rate: i32 = 10; // out of 100
        let mut i: usize = 0;
        while (i < 16) {
            if (pseudo_rand(seed) % 100 < mutation_rate) {
                chrom.genes[i as usize] = chrom.genes[i as usize] + (pseudo_rand(seed) % 20 - 10);
            }
            i = i + 1;
        }
    }

    init_population(&mut population, &mut rng_seed);

    let mut generation: i32 = 0;
    while (generation < 50) {
        evaluate_population(&mut population);
        let mut new_population: [Chromosome; 64] = [Chromosome {
            genes: [0; 16],
            fitness: 0,
        }; 64];

        let mut i: usize = 0;
        while (i < 64) {
            let p1_idx: usize = selection(&population, &mut rng_seed) as usize;
            let p2_idx: usize = selection(&population, &mut rng_seed) as usize;
            crossover(
                &population[p1_idx as usize],
                &population[p2_idx as usize],
                &mut new_population[i as usize],
                &mut rng_seed,
            );
            mutate(&mut new_population[i as usize], &mut rng_seed);
            i = i + 1;
        }

        // Hidden Error: The variable `i` is re-declared in this inner scope,
        // shadowing the outer `i`. A compiler should catch this re-declaration
        // in the same function block.
        let mut i: usize = 0;
        while (i < 64) {
            population[i as usize] = new_population[i as usize];
            i = i + 1;
        }
        generation = generation + 1;
    }

    evaluate_population(&mut population);
    let mut best_fitness: i32 = -99999999;
    let mut i: usize = 0;
    while (i < 64) {
        if (population[i as usize].fitness > best_fitness) {
            best_fitness = population[i as usize].fitness;
        }
        i = i + 1;
    }
    printlnInt(best_fitness);
    exit(0);
}
