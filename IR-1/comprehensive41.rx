/*
Test Package: Semantic-2
Test Target: comprehensive
Author: Wenxin Zheng
Time: 2025-08-17
Verdict: Pass
Test Name: Simulation of a Simple File System
Summary: This test comprehensively evaluates compiler optimizations for:
Details:
Simulating a block-based file system using a large array.
Managing complex, interconnected data structures (inodes, data blocks, free lists).
Pointer-like logic using array indices for block references.
Deeply nested logic for file operations (create, write, read, delete).
Optimization of loops for searching directories and allocating blocks.
Handling of error conditions and state consistency.
Correctness of variable lifetimes and mutability in a complex simulation.
*/

// comprehensive41.rx - Simulation of a Simple File System
// This test comprehensively evaluates compiler optimizations for:
// - Simulating a block-based file system using a large array.
// - Managing complex, interconnected data structures (inodes, data blocks, free lists).
// - Pointer-like logic using array indices for block references.
// - Deeply nested logic for file operations (create, write, read, delete).
// - Optimization of loops for searching directories and allocating blocks.
// - Handling of error conditions and state consistency.
// - Correctness of variable lifetimes and mutability in a complex simulation.

const BLOCK_SIZE: i32 = 64;
const NUM_BLOCKS: i32 = 256;
const FS_SIZE: i32 = BLOCK_SIZE * NUM_BLOCKS;
const MAX_INODES: i32 = 128;
const MAX_FILENAME_LEN: i32 = 16;
const INODE_SIZE: i32 = 24;
const ROOT_INODE_NUM: i32 = 0;

const INODE_TYPE_FREE: i32 = 0;
const INODE_TYPE_FILE: i32 = 1;
const INODE_TYPE_DIR: i32 = 2;

struct FS {
    fs_data: [i32; 16384],
    inode_table_type: [i32; 128],
    inode_table_size: [i32; 128],
    inode_table_blocks: [[i32; 6]; 128],
    free_block_bitmap: [bool; 256],
    free_inode_bitmap: [bool; 128],
}

fn new_fs() -> FS {
    let fs: FS = FS {
        fs_data: [0; 16384],
        inode_table_type: [0; 128],
        inode_table_size: [0; 128],
        inode_table_blocks: [[0; 6]; 128],
        free_block_bitmap: [false; 256],
        free_inode_bitmap: [false; 128],
    };
    return fs;
}

fn fs_format(fs: &mut FS) {
    let mut i: i32 = 0;
    while (i < NUM_BLOCKS) {
        fs.free_block_bitmap[i as usize] = true;
        i = i + 1;
    }
    i = 0;
    while (i < MAX_INODES) {
        fs.free_inode_bitmap[i as usize] = true;
        i = i + 1;
    }

    let root_inode: i32 = allocate_inode(fs);
    let root_block: i32 = allocate_block(fs);
    fs.inode_table_type[root_inode as usize] = INODE_TYPE_DIR;
    fs.inode_table_size[root_inode as usize] = 0;
    fs.inode_table_blocks[root_inode as usize][0] = root_block;
}

fn allocate_inode(fs: &mut FS) -> i32 {
    let mut i: i32 = 0;
    while (i < MAX_INODES) {
        if (fs.free_inode_bitmap[i as usize]) {
            fs.free_inode_bitmap[i as usize] = false;
            fs.inode_table_type[i as usize] = INODE_TYPE_FREE;
            fs.inode_table_size[i as usize] = 0;
            let mut j: i32 = 0;
            while (j < 6) {
                fs.inode_table_blocks[i as usize][j as usize] = 0;
                j = j + 1;
            }
            return i;
        }
        i = i + 1;
    }
    return -1;
}

fn allocate_block(fs: &mut FS) -> i32 {
    let mut i: i32 = 0;
    while (i < NUM_BLOCKS) {
        if (fs.free_block_bitmap[i as usize]) {
            fs.free_block_bitmap[i as usize] = false;
            return i;
        }
        i = i + 1;
    }
    return -1;
}

fn find_in_dir(fs: &FS, dir_inode_num: i32, filename: [i32; 16]) -> i32 {
    let dir_size: i32 = fs.inode_table_size[dir_inode_num as usize];
    let num_entries: i32 = dir_size / INODE_SIZE;
    let mut i: i32 = 0;
    while (i < num_entries) {
        let block_idx: i32 = i * INODE_SIZE / BLOCK_SIZE;
        let offset_in_block: i32 = (i * INODE_SIZE) % BLOCK_SIZE;
        let data_block: i32 = fs.inode_table_blocks[dir_inode_num as usize][block_idx as usize];
        let entry_addr: i32 = data_block * BLOCK_SIZE + offset_in_block;

        let mut flag: bool = true;
        let mut j: i32 = 0;
        while (j < MAX_FILENAME_LEN) {
            if (fs.fs_data[(entry_addr + j) as usize] != filename[j as usize]) {
                flag = false;
                break;
            }
            j = j + 1;
        }
        if (flag) {
            return fs.fs_data[(entry_addr + MAX_FILENAME_LEN) as usize];
        }
        i = i + 1;
    }
    return -1;
}

fn create_file(fs: &mut FS, parent_dir_inode: i32, filename: [i32; 16]) -> i32 {
    if (find_in_dir(fs, parent_dir_inode, filename) != -1) {
        return -1;
    }
    let new_inode_num: i32 = allocate_inode(fs);
    if (new_inode_num == -1) {
        return -1;
    }
    fs.inode_table_type[new_inode_num as usize] = INODE_TYPE_FILE;

    let dir_size: i32 = fs.inode_table_size[parent_dir_inode as usize];
    let block_idx: i32 = dir_size / BLOCK_SIZE;
    let offset_in_block: i32 = dir_size % BLOCK_SIZE;
    let data_block: i32 = fs.inode_table_blocks[parent_dir_inode as usize][block_idx as usize];
    let entry_addr: i32 = data_block * BLOCK_SIZE + offset_in_block;

    let mut i: i32 = 0;
    while (i < MAX_FILENAME_LEN) {
        fs.fs_data[(entry_addr + i) as usize] = filename[i as usize];
        i = i + 1;
    }
    fs.fs_data[(entry_addr + MAX_FILENAME_LEN) as usize] = new_inode_num;
    fs.inode_table_size[parent_dir_inode as usize] = dir_size + INODE_SIZE;

    return new_inode_num;
}

fn write_file(fs: &mut FS, inode_num: i32, data: [i32; 100], len: i32) -> i32 {
    let mut bytes_written: i32 = 0;
    let mut data_ptr: i32 = 0;
    let mut block_alloc_count: i32 = 0;
    // Clamp requested length to the size of the provided data buffer to avoid out-of-bounds.
    let mut max_len: i32 = len;
    if (max_len > 100) {
        max_len = 100;
    }

    while (data_ptr < max_len) {
        let block_idx: i32 = fs.inode_table_size[inode_num as usize] / BLOCK_SIZE;
        if (block_idx >= 6) {
            return -1;
        }
        let mut current_block: i32 = fs.inode_table_blocks[inode_num as usize][block_idx as usize];
        if (current_block == 0) {
            current_block = allocate_block(fs);
            if (current_block == -1) {
                return -1;
            }
            fs.inode_table_blocks[inode_num as usize][block_idx as usize] = current_block;
            block_alloc_count = block_alloc_count + 1;
        }

        let offset_in_block: i32 = fs.inode_table_size[inode_num as usize] % BLOCK_SIZE;
        let write_addr: i32 = current_block * BLOCK_SIZE + offset_in_block;
        fs.fs_data[write_addr as usize] = data[data_ptr as usize];

        fs.inode_table_size[inode_num as usize] = fs.inode_table_size[inode_num as usize] + 1;
        data_ptr = data_ptr + 1;
        bytes_written = bytes_written + 1;
    }
    return bytes_written;
}

fn read_file(fs: &FS, inode_num: i32) -> i32 {
    let size: i32 = fs.inode_table_size[inode_num as usize];
    let mut checksum: i32 = 0;
    let mut bytes_read: i32 = 0;

    while (bytes_read < size) {
        let block_idx: i32 = bytes_read / BLOCK_SIZE;
        let offset_in_block: i32 = bytes_read % BLOCK_SIZE;
        let data_block: i32 = fs.inode_table_blocks[inode_num as usize][block_idx as usize];
        let read_addr: i32 = data_block * BLOCK_SIZE + offset_in_block;
        checksum = checksum + fs.fs_data[read_addr as usize];
        bytes_read = bytes_read + 1;
    }
    return checksum;
}

fn str_to_arr(s: i32) -> [i32; 16] {
    let mut arr: [i32; 16] = [0; 16];
    if (s == 1) {
        arr[0] = 102; arr[1] = 105; arr[2] = 108; arr[3] = 101; arr[4] = 49;
    } else if (s == 2) {
        arr[0] = 100; arr[1] = 97; arr[2] = 116; arr[3] = 97;
    } else if (s == 3) {
        arr[0] = 116; arr[1] = 101; arr[2] = 109; arr[3] = 112;
    }
    return arr;
}

fn main() {
    let mut fs: FS = new_fs();
    fs_format(&mut fs);

    let file1_name: [i32; 16] = str_to_arr(1);
    let file1_inode: i32 = create_file(&mut fs, ROOT_INODE_NUM, file1_name);
    printlnInt(file1_inode);

    let mut data1: [i32; 100] = [0; 100];
    let mut i: i32 = 0;
    while (i < 100) {
        data1[i as usize] = i * 3;
        i = i + 1;
    }
    let written1: i32 = write_file(&mut fs, file1_inode, data1, 80);
    printlnInt(written1);

    let checksum1: i32 = read_file(&fs, file1_inode);
    printlnInt(checksum1);

    let file2_name: [i32; 16] = str_to_arr(2);
    let file2_inode: i32 = create_file(&mut fs, ROOT_INODE_NUM, file2_name);
    printlnInt(file2_inode);

    let mut data2: [i32; 100] = [0; 100];
    i = 0;
    while (i < 100) {
        data2[i as usize] = 100 - i;
        i = i + 1;
    }
    let written2: i32 = write_file(&mut fs, file2_inode, data2, 150);
    printlnInt(written2);

    let checksum2: i32 = read_file(&fs, file2_inode);
    printlnInt(checksum2);

    let found_inode: i32 = find_in_dir(&fs, ROOT_INODE_NUM, file1_name);
    printlnInt(found_inode);

    let not_found_name: [i32; 16] = str_to_arr(3);
    let not_found_inode: i32 = find_in_dir(&fs, ROOT_INODE_NUM, not_found_name);
    printlnInt(not_found_inode);

    let mut free_blocks: i32 = 0;
    i = 0;
    while (i < NUM_BLOCKS) {
        if (fs.free_block_bitmap[i as usize]) {
            free_blocks = free_blocks + 1;
        }
        i = i + 1;
    }
    printlnInt(free_blocks);

    let mut free_inodes: i32 = 0;
    i = 0;
    while (i < MAX_INODES) {
        if (fs.free_inode_bitmap[i as usize]) {
            free_inodes = free_inodes + 1;
        }
        i = i + 1;
    }
    printlnInt(free_inodes);

    let mut fs_checksum: i32 = 0;
    i = 0;
    while (i < FS_SIZE) {
        fs_checksum = fs_checksum + fs.fs_data[i as usize];
        i = i + 1;
    }
    printlnInt(fs_checksum % 10000);

    let mut j: i32 = 0;
    while (j < 10) {
        let mut data: [i32; 100] = [0; 100];
        let mut k: i32 = 0;
        while (k < 10) {
            data[k as usize] = j * 10 + k;
            k = k + 1;
        }
        write_file(&mut fs, file1_inode, data, 10);
        j = j + 1;
    }
    printlnInt(read_file(&fs, file1_inode));

    let mut final_status: i32 = 1;
    let mut k: i32 = 0;
    while (k < 5) {
        let mut final_status: i32 = final_status + k;
        k = k + 1;
    }
    printlnInt(final_status);
    exit(0);
}
