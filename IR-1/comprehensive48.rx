/*
Test Package: Semantic-2
Test Target: comprehensive
Author: Wenxin Zheng
Time: 2025-08-17
Verdict: Pass
Test Name: Advanced Logistics and Supply Chain Simulation
Summary: This test comprehensively evaluates compiler optimizations for:
Details:
Management of complex, nested data structures for inventory and orders
Optimization of array-heavy operations for stock management
Branch prediction and optimization in complex conditional logic for order processing
Function call optimization in a deeply nested call graph
Integer arithmetic and data flow analysis in a simulated environment
Corner case handling for stock levels (e.g., zero stock, backorders)
*/

// comprehensive48.rx - Advanced Logistics and Supply Chain Simulation
// This test comprehensively evaluates compiler optimizations for:
// - Management of complex, nested data structures for inventory and orders
// - Optimization of array-heavy operations for stock management
// - Branch prediction and optimization in complex conditional logic for order processing
// - Function call optimization in a deeply nested call graph
// - Integer arithmetic and data flow analysis in a simulated environment
// - Corner case handling for stock levels (e.g., zero stock, backorders)

fn main() {
    let mut warehouse_stock_A: i32 = 1000;
    let mut warehouse_stock_B: i32 = 1500;
    let mut warehouse_stock_C: i32 = 800;

    let mut pending_orders_A: i32 = 0;
    let mut pending_orders_B: i32 = 0;
    let mut pending_orders_C: i32 = 0;

    let mut processed_orders: i32 = 0;
    let mut total_revenue: i32 = 0;

    let price_A: i32 = 10;
    let price_B: i32 = 15;
    let price_C: i32 = 20;

    let mut i: i32 = 0;
    while (i < 200) {
        let order_type: i32 = i % 3;
        let order_quantity: i32 = (i * 7 + 15) % 50 + 10;

        if (order_type == 0) {
            pending_orders_A = pending_orders_A + order_quantity;
        } else {
            if (order_type == 1) {
                pending_orders_B = pending_orders_B + order_quantity;
            } else {
                pending_orders_C = pending_orders_C + order_quantity;
            }
        }

        if (i % 10 == 0) {
            warehouse_stock_A = warehouse_stock_A + 200;
            warehouse_stock_B = warehouse_stock_B + 300;
            warehouse_stock_C = warehouse_stock_C + 150;
        }

        let mut can_process_A: bool = false;
        let mut can_process_B: bool = false;
        let mut can_process_C: bool = false;

        if (pending_orders_A > 0) {
            if (warehouse_stock_A >= pending_orders_A) {
                can_process_A = true;
            }
        }
        if (pending_orders_B > 0) {
            if (warehouse_stock_B >= pending_orders_B) {
                can_process_B = true;
            }
        }
        if (pending_orders_C > 0) {
            if (warehouse_stock_C >= pending_orders_C) {
                can_process_C = true;
            }
        }

        let mut special_bonus: i32 = 0;

        if (can_process_A) {
            let revenue_A: i32 = if (pending_orders_A > 50) {
                let discount: i32 = 5;
                special_bonus = 100;
                pending_orders_A * (price_A - discount)
            } else {
                pending_orders_A * price_A
            };
            warehouse_stock_A = warehouse_stock_A - pending_orders_A;
            total_revenue = total_revenue + revenue_A;
            processed_orders = processed_orders + pending_orders_A;
            pending_orders_A = 0;
        }

        if (can_process_B) {
            let revenue_B: i32 = if (pending_orders_B > 40) {
                let discount: i32 = 3;
                pending_orders_B * (price_B - discount)
            } else {
                pending_orders_B * price_B
            };
            warehouse_stock_B = warehouse_stock_B - pending_orders_B;
            total_revenue = total_revenue + revenue_B;
            processed_orders = processed_orders + pending_orders_B;
            pending_orders_B = 0;
        }

        if (can_process_C) {
            let revenue_C: i32 = if (pending_orders_C > 30) {
                let discount: i32 = 2;
                pending_orders_C * (price_C - discount)
            } else {
                pending_orders_C * price_C
            };
            warehouse_stock_C = warehouse_stock_C - pending_orders_C;
            total_revenue = total_revenue + revenue_C;
            processed_orders = processed_orders + pending_orders_C;
            pending_orders_C = 0;
        }

        if (i % 25 == 0) {
            let audit_result: i32 = perform_audit(
                warehouse_stock_A,
                warehouse_stock_B,
                warehouse_stock_C,
                total_revenue,
            );
            if (audit_result < 0) {
                total_revenue = total_revenue + special_bonus;
            }
        }

        i = i + 1;
    }

    printlnInt(total_revenue);
    printlnInt(processed_orders);
    printlnInt(warehouse_stock_A);
    printlnInt(warehouse_stock_B);
    printlnInt(warehouse_stock_C);
    exit(0);
}

fn perform_audit(stock_a: i32, stock_b: i32, stock_c: i32, revenue: i32) -> i32 {
    let mut score: i32 = 0;
    if (stock_a < 100) {
        score = score - 10;
    } else {
        score = score + 5;
    }
    if (stock_b < 150) {
        score = score - 10;
    } else {
        score = score + 5;
    }
    if (stock_c < 80) {
        score = score - 10;
    } else {
        score = score + 5;
    }

    if (revenue > 50000) {
        score = score + 20;
    } else {
        if (revenue > 20000) {
            score = score + 10;
        }
    }

    let mut i: i32 = 0;
    let mut temp_rev: i32 = revenue;
    while (i < 5) {
        temp_rev = temp_rev / (i + 1);
        i = i + 1;
    }
    score = score + temp_rev % 10;

    if (score > 15) {
        1
    } else {
        if (score > 0) {
            0
        } else {
            -1
        }
    }
}

fn another_level_of_processing(data: i32, factor: i32) -> i32 {
    let mut i: i32 = 0;
    let mut result: i32 = data;
    while (i < 10) {
        if (i % 2 == 0) {
            result = result + (factor * i);
        } else {
            result = result - (factor * i / 2);
        }
        let mut j: i32 = 0;
        while (j < 5) {
            result = result + j;
            j = j + 1;
        }
        i = i + 1;
    }
    result
}

fn yet_another_function(val1: i32, val2: i32) -> i32 {
    let mut intermediate: i32 = if (val1 > val2) {
        val1 - val2
    } else {
        val2 - val1
    };

    let mut k: i32 = 0;
    while (k < 5) {
        intermediate = another_level_of_processing(intermediate, k + 1);
        k = k + 1;
    }

    if (intermediate > 1000) {
        return 1000;
    }
    intermediate
}

fn process_complex_data(a: i32, b: i32, c: i32) -> i32 {
    let mut res1: i32 = yet_another_function(a, b);
    let mut res2: i32 = yet_another_function(b, c);
    let mut res3: i32 = yet_another_function(a, c);

    let mut final_val: i32 = res1 + res2 + res3;

    let mut i: i32 = 0;
    while (i < 10) {
        final_val = final_val - i * i;
        i = i + 1;
    }
    final_val
}

fn simulate_external_factors(current_rev: i32) -> i32 {
    let market_condition: i32 = current_rev % 5;
    if (market_condition == 0) {
        -500
    } else {
        if (market_condition == 1) {
            200
        } else {
            if (market_condition == 2) {
                0
            } else {
                if (market_condition == 3) {
                    1000
                } else {
                    -100
                }
            }
        }
    }
}

fn final_check(stock_a: i32, stock_b: i32, stock_c: i32, revenue: i32) -> i32 {
    let mut score: i32 = 0;
    if (stock_a > 500) {
        score = score + 1;
    }
    if (stock_b > 800) {
        score = score + 1;
    }
    if (stock_c > 400) {
        score = score + 1;
    }
    if (revenue > 100000) {
        score = score + 2;
    }
    score
}
